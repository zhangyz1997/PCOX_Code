---
title: "PCOX Data Mining"
author: "张远哲"
date: "`r Sys.Date()`"
output: html_document
params:
  filter_uncertain: TRUE
  pipeline: "edger"
  division_criteria: "response"
  includekgh: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  fig.width=12, fig.height=8,
  out.height = '95%',
	echo = TRUE,
	message = FALSE,
	warning = FALSE,
  error = TRUE
)
library(readxl)
library(writexl)
library(maftools)
library(org.Hs.eg.db)
library(clusterProfiler)
library(enrichplot)
library(ggpubr)
library(IOBR)
library(msigdbr)
library(ReactomePA)
library(tinyarray)
library(tidyverse)
options(clusterProfiler.download.method = "wininet") #修正KEGG现在强制https的bug
kegg_SYMBOL_hsa <- function(genes){ 
  gene.df <- bitr(genes, fromType = "SYMBOL",
                  toType = c("SYMBOL", "ENTREZID"),
                  OrgDb = org.Hs.eg.db)
  head(gene.df) 
  diff.kk <- enrichKEGG(gene         = gene.df$ENTREZID,
                        organism     = 'hsa',
                        pvalueCutoff = 0.99,
                        qvalueCutoff = 0.99
  )
  return(setReadable(diff.kk, OrgDb = org.Hs.eg.db,keyType = 'ENTREZID'))
}
excel2maf <- function(wes_result){
  wes_maf <- data.frame(
    Hugo_Symbol = wes_result$symbol,
    Chromosome = stringr::str_sub(wes_result$chr,4),
    Start_Position = as.numeric(wes_result$position),
    End_Position = as.numeric(wes_result$position),
    Tumor_Sample_Barcode = wes_result$patient_id,
    Reference_Allele = wes_result$ref,
    Tumor_Seq_Allele2 = wes_result$alt,
    # Variant_Type = "SNP",
    HGVSp_Short = wes_result$aminochange_ts,
    VAF = wes_result$tumor_alt_depth / (wes_result$tumor_alt_depth+wes_result$tumor_refer_depth) * 100
  ) %>%
    mutate(
      # 参考 https://github.com/mskcc/vcf2maf/blob/main/vcf2maf.pl 转化突变类型
      Variant_Classification = case_when(
        wes_result$mutationtype %in% c("splice_acceptor_variant","splice_donor_variant","transcript_ablation","exon_loss_variant") ~ "Splice_Site",
        wes_result$mutationtype == "splice_region_variant" ~ "Splice_Region",
        wes_result$mutationtype == "3_prime_UTR_variant" ~ "3'UTR",
        wes_result$mutationtype == "5_prime_UTR_variant" ~ "5'UTR",
        wes_result$mutationtype == "downstream_gene_variant" ~ "3'Flank",
        wes_result$mutationtype == "upstream_gene_variant" ~ "5'Flank",
        wes_result$mutationtype == "intron_variant" ~ "Intron",
        wes_result$mutationtype == "missense_variant" ~ "Missense_Mutation",
        wes_result$mutationtype == "non_coding_transcript_exon_variant" ~ "RNA",
        wes_result$mutationtype == "start_lost" ~ "Translation_Start_Site",
        wes_result$mutationtype == "stop_lost" ~ "Nonstop_Mutation",
        wes_result$mutationtype == "stop_gained" ~ "Nonsense_Mutation",
        wes_result$mutationtype %in% c("stop_retained_variant","synonymous_variant") ~ "Silent",
        wes_result$mutationtype == "frameshift_variant" & stringr::str_detect(wes_result$cdnachange_ts, "del") ~ "Frame_Shift_Del",         wes_result$mutationtype == "frameshift_variant" & (stringr::str_detect(wes_result$cdnachange_ts, "ins")|stringr::str_detect(wes_result$cdnachange_ts, "dup")) ~ "Frame_Shift_Ins",
        wes_result$mutationtype == "inframe_deletion" ~ "In_Frame_Del",
        wes_result$mutationtype == "inframe_insertion" ~ "In_Frame_Ins"),
      Variant_Type = case_when(
        wes_result$mutationtype == "frameshift_variant" & stringr::str_detect(wes_result$cdnachange_ts, "del") ~ "DEL",         
        wes_result$mutationtype == "frameshift_variant" & (stringr::str_detect(wes_result$cdnachange_ts, "ins")|stringr::str_detect(wes_result$cdnachange_ts, "dup")) ~ "INS",
        wes_result$mutationtype == "inframe_deletion" ~ "DEL",
        wes_result$mutationtype == "inframe_insertion" ~ "INS",
        TRUE ~ "SNP")
    )
  return(wes_maf)
}
clinic <- read_xlsx("./data/clinical.xlsx") %>% filter(is.na(`编号`) == FALSE)
clinic$Tumor_Sample_Barcode <- clinic$'编号'
clinic$response[clinic$response == "/"] <- 1
clinic$PD[clinic$PD == "/"] <- 0
immport_genelist <- read.table(file = "./data/GeneList.txt", header = T, sep = "\t")

uncertain_patients <- c("黄斌","张华酬","叶国连")

uncertain_list <- clinic %>%
  filter(姓名 %in% uncertain_patients) %>%
  dplyr::select(c("姓名","Tumor_Sample_Barcode"))

if(params$includekgh == FALSE){
  clinic <- clinic %>% filter(姓名 != "柯国浩")
}

clinic_detailed <- read_xlsx("./data/20220524更新1005.xlsx") %>% filter(姓名 %in% clinic$姓名)
clinic$surgery <- clinic_detailed$surgery[match(clinic$姓名, clinic_detailed$姓名)]
clinic$cr <- clinic_detailed$研究者_CR[match(clinic$姓名, clinic_detailed$姓名)]

```

## WES数据分析

```{r wes_data_prep, include=FALSE}
## 读取WES的数据并整理为MAF格式
wes_snp <- read_xlsx("./data/wes.xlsx", sheet = "SNP")
wes_cnv <- read_xlsx("./data/wes.xlsx", sheet = "CNV")
wes_maf <- read.maf(maf = "./data/group_all.maf")@data

wes_maf$Tumor_Sample_Barcode <- stringr::str_sub(wes_maf$Tumor_Sample_Barcode,1,6)
wes_maf_snp <- data.frame(
  Hugo_Symbol = wes_snp$symbol,
  Chromosome = stringr::str_sub(wes_snp$chr,4),
  Start_Position = as.numeric(wes_snp$position),
  End_Position = as.numeric(wes_snp$position),
  Tumor_Sample_Barcode = wes_snp$patient_id,
  Reference_Allele = wes_snp$ref,
  Tumor_Seq_Allele2 = wes_snp$alt,
  Variant_Type = "SNP",
  HGVSp_Short = wes_snp$aminochange_ts,
  VAF = wes_snp$tumor_alt_depth / (wes_snp$tumor_alt_depth+wes_snp$tumor_refer_depth) * 100
) %>%
  mutate(
    # 参考 https://github.com/mskcc/vcf2maf/blob/main/vcf2maf.pl 转化突变类型
    Variant_Classification = case_when(
      wes_snp$mutationtype %in% c("splice_acceptor_variant","splice_donor_variant","transcript_ablation","exon_loss_variant") ~ "Splice_Site",
      wes_snp$mutationtype == "splice_region_variant" ~ "Splice_Region",
      wes_snp$mutationtype == "3_prime_UTR_variant" ~ "3'UTR",
      wes_snp$mutationtype == "5_prime_UTR_variant" ~ "5'UTR",
      wes_snp$mutationtype == "downstream_gene_variant" ~ "3'Flank",
      wes_snp$mutationtype == "upstream_gene_variant" ~ "5'Flank",
      wes_snp$mutationtype == "intron_variant" ~ "Intron",
      wes_snp$mutationtype == "missense_variant" ~ "Missense_Mutation",
      wes_snp$mutationtype == "non_coding_transcript_exon_variant" ~ "RNA",
      wes_snp$mutationtype == "start_lost" ~ "Translation_Start_Site",
      wes_snp$mutationtype == "stop_lost" ~ "Nonstop_Mutation",
      wes_snp$mutationtype == "stop_gained" ~ "Nonsense_Mutation",
      wes_snp$mutationtype %in% c("stop_retained_variant","synonymous_variant") ~ "Silent"
    )
  ) %>%
  filter(Tumor_Sample_Barcode %in% wes_maf$Tumor_Sample_Barcode == FALSE)

cntable_wes <- wes_cnv %>% 
  dplyr::select(symbol, patient_id, haploid) %>%
  mutate(cnv_status = case_when(
    haploid >= 3 ~ "Amp",
    haploid <= 1.2 ~ "Del",
    TRUE ~ NA_character_
  )) %>%
  filter(is.na(cnv_status) == FALSE) %>%
  dplyr::select(symbol, patient_id, cnv_status) %>%
  unique()
if(params$includekgh == TRUE){
  ### 专门读取柯国浩的WES数据
  wes_snp_kgh <- read.table("./data/A14525_柯国浩/A14525_N5251803D_T5253418D_P011452501_TNscope_somatic_pass_vep_snp_filtered.txt", header = TRUE, sep = "\t")
  wes_indel_kgh <- read.table("./data/A14525_柯国浩/A14525_N5251803D_T5253418D_P011452501_TNscope_somatic_pass_vep_indel_filtered.txt", header = TRUE, sep = "\t")
  wes_maf_snp_kgh <- excel2maf(wes_snp_kgh)
wes_maf_indel_kgh <- excel2maf(wes_indel_kgh)
construct_maf <- merge_mafs(list(read.maf(wes_maf), read.maf(wes_maf_snp), read.maf(wes_maf_snp_kgh), read.maf(wes_maf_indel_kgh)))
construct_maf <- read.maf(construct_maf@data, clinicalData = clinic, cnTable = cntable_wes, rmFlags = TRUE)
}else{
  construct_maf <- merge_mafs(list(read.maf(wes_maf), read.maf(wes_maf_snp)))
  construct_maf <- read.maf(construct_maf@data, clinicalData = clinic, cnTable = cntable_wes, rmFlags = TRUE)
}

if(params$filter_uncertain == TRUE){
  construct_maf <- filterMaf(construct_maf, tsb = uncertain_list$Tumor_Sample_Barcode)
}else{
  if(length(which(construct_maf@clinical.data$response == "/")) != 0){
    construct_maf@clinical.data$response[which(construct_maf@clinical.data$response == "/")] <- "1"
  }
  if(length(which(construct_maf@clinical.data$PD == "/")) != 0){
    construct_maf@clinical.data$PD[which(construct_maf@clinical.data$PD == "/")] <- "0"
  }
}
```

### 突变全景

直观展示突变和PFS/response的关系

```{r oncoplot,results='hide',fig.keep='all'}
oncoplot(
  maf = construct_maf,
  top = 25,
  clinicalFeatures = c("response", "PFS_event"),
  fontSize = 0.6,
  # legendFontSize = 0.6,
  # annotationFontSize = 0.6,
  anno_height = 1,
  # pathways = "auto",
  sortByAnnotation = TRUE
)
# 查看抗原提呈相关的基因突变
apm_genes <- unique(c(signature_collection$Antigen_Processing_and_Presentation_Li_et_al, kegg$KEGG_ANTIGEN_PROCESSING_AND_PRESENTATION, signature_collection$APM, signature_collection$TIP_Cancer_antigen_presentation_1, signature_collection$TIP_Cancer_antigen_presentation_2))
oncoplot(
  maf = subsetMaf(construct_maf, genes = apm_genes),
  # top = length(apm_genes),
  clinicalFeatures = c("response", "PFS_event"),
  fontSize = 0.6,
  # legendFontSize = 0.6,
  # annotationFontSize = 0.6,
  anno_height = 1,
  # pathways = "auto",
  sortByAnnotation = TRUE,
  titleText = "APM Combined"
)
oncoplot(
  maf = subsetMaf(construct_maf, genes = signature_collection$APM),
  # top = length(apm_genes),
  clinicalFeatures = c("response", "PFS_event"),
  fontSize = 0.6,
  # legendFontSize = 0.6,
  # annotationFontSize = 0.6,
  anno_height = 1,
  # pathways = "auto",
  sortByAnnotation = TRUE,
  titleText = "APM Signature"
)
oncoplot(
  maf = subsetMaf(construct_maf, genes = kegg$KEGG_ANTIGEN_PROCESSING_AND_PRESENTATION),
  # top = length(kegg$KEGG_ANTIGEN_PROCESSING_AND_PRESENTATION),
  clinicalFeatures = c("response", "PFS_event"),
  fontSize = 0.6,
  anno_height = 1,
  # pathways = "auto",
  sortByAnnotation = TRUE,
  titleText = "APM KEGG"
)
oncoplot(
  maf = subsetMaf(construct_maf, genes = kegg$KEGG_JAK_STAT_SIGNALING_PATHWAY),
  # top = length(apm_genes),
  clinicalFeatures = c("response", "PFS_event"),
  fontSize = 0.6,
  legendFontSize = 0.6,
  annotationFontSize = 0.6,
  anno_height = 1,
  # pathways = "auto",
  sortByAnnotation = TRUE,
  titleText = "JAK_STAT KEGG"
)
oncoplot(
  maf = subsetMaf(construct_maf, genes = signature_collection$Antigen_Processing_and_Presentation_Li_et_al),
  # top = length(apm_genes),
  clinicalFeatures = c("response", "PFS_event"),
  anno_height = 1,
  # pathways = "auto",
  sortByAnnotation = TRUE,
  titleText = "APM Li_et.al"
)
immport_genelist_mut <- immport_genelist %>%
  filter(Symbol %in% construct_maf@data$Hugo_Symbol) %>%
  dplyr::select(Symbol, Category)
lapply(levels(as.factor(immport_genelist_mut$Category)), function(x){
  oncoplot(
  maf = subsetMaf(construct_maf, genes = immport_genelist$Symbol[which(immport_genelist$Category == x)]),
  top = 20,
  clinicalFeatures = c("response", "PFS_event"),
  # anno_height = 1,
  # pathways = "auto",
  sortByAnnotation = TRUE,
  titleText = x,
  showTumorSampleBarcodes = TRUE,
  cBioPortal = TRUE
)
})

```

### 富集各组的突变基因

~~第一张图是 是否Response 的比较(富集到[MUC16](https://jamanetwork.com/journals/jamanetworkopen/fullarticle/2767064)), 第二张图是 是否进展 的比较~~

```{r enrichplot,eval=TRUE}
response_enrich <- clinicalEnrichment(
  maf = construct_maf,
  clinicalFeature = "response",
  annotationDat = NULL,
  minMut = 2,
  useCNV = FALSE,
  pathways = FALSE
)
PFS_enrich <- clinicalEnrichment(
  maf = construct_maf,
  clinicalFeature = "PD",
  annotationDat = NULL,
  # minMut = 5,
  useCNV = FALSE,
  pathways = FALSE
)
plotEnrichmentResults(response_enrich,
                      pVal = 0.05,
                      ORthr = 1,
                      featureLvls = NULL,
                      cols = NULL,
                      # annoFontSize = 0.8,
                      # geneFontSize = 0.8,
                      # legendFontSize = 0.8
                      )
lollipopPlot(maf = construct_maf, gene = "PTCH1")
mafSurvival(maf = construct_maf, genes = c("KRAS","NRAS","BRAF"), clinicalData = clinic, time = "PFS", Status = "PD")

pathway_enrich <- clinicalEnrichment(
  maf = construct_maf,
  clinicalFeature = "response",
  annotationDat = NULL,
  minMut = 2,
  useCNV = FALSE,
  pathways = TRUE
)
plotEnrichmentResults(pathway_enrich)
OncogenicPathways(maf = construct_maf)
```

~~### 驱动基因和通路分析~~

```{r oncodrive, message=FALSE, warning=FALSE, results='hide', fig.keep='all',eval=FALSE}
if(F){
  response.sig <- oncodrive(maf=subsetMaf(construct_maf, clinQuery = "response != '0'"), minMut=5, AACol="HGVSp_Short", pvalMethod="zscore")
  plotOncodrive(res = response.sig, fdrCutOff = 0.1, useFraction = TRUE)
  nonresponse.sig <- oncodrive(maf=subsetMaf(construct_maf, clinQuery = "response == '0'"), minMut=5, AACol="HGVSp_Short", pvalMethod="zscore")
  plotOncodrive(res = nonresponse.sig, fdrCutOff = 0.1, useFraction = TRUE)
}
OncogenicPathways(maf=subsetMaf(construct_maf, clinQuery = "response != '0'"))
OncogenicPathways(maf=subsetMaf(construct_maf, clinQuery = "response == '0'"))
```

### TMB分析

```{r tmb, echo=FALSE}
canc_tmb <- merge(x = data.frame(maftools::tmb(maf = construct_maf)), y = clinic %>% dplyr::select(c( "编号","response")),
  by.x = "Tumor_Sample_Barcode",
  by.y = "编号")
canc_tmb$response[which(canc_tmb$response == "/")] <- "1"
canc_tmb$response <- as.factor(canc_tmb$response)
ggplot(canc_tmb,aes(x = response,y = total_perMB_log)) + 
  geom_boxplot() + 
  labs(x = "Response", y = "logTMB") +
  stat_compare_means(method = "wilcox.test")
ggplot(canc_tmb,aes(x = response,y = total_perMB_log)) + 
  geom_violin() + 
  labs(x = "Response", y = "logTMB") +
  stat_compare_means(method = "wilcox.test")
```

### KEGG突变通路富集

上图为应答者的,下图为非应答者的

```{r kegg_mut}
## KEGG通路富集
library(org.Hs.eg.db)
library(clusterProfiler)
kegg_SYMBOL_hsa <- function(genes){ 
  gene.df <- bitr(genes, fromType = "SYMBOL",
                  toType = c("SYMBOL", "ENTREZID"),
                  OrgDb = org.Hs.eg.db)
  head(gene.df) 
  diff.kk <- enrichKEGG(gene         = gene.df$ENTREZID,
                        organism     = 'hsa',
                        pvalueCutoff = 0.99,
                        qvalueCutoff = 0.99
  )
  return(setReadable(diff.kk, OrgDb = org.Hs.eg.db,keyType = 'ENTREZID'))
}

mut_matrix <- mutCountMatrix(construct_maf)
geneList <- list()
geneList[["response"]] <- mut_matrix[, intersect(colnames(mut_matrix), clinic$编号[clinic$response == "1" & is.na(clinic$编号) == FALSE])] %>% rowSums(.)
geneList[["response"]] <- names(geneList[["response"]][which(geneList[["response"]] != 0)])
geneList[["noresponse"]] <- mut_matrix[, intersect(colnames(mut_matrix), clinic$编号[clinic$response == "0" & is.na(clinic$编号) == FALSE])] %>% rowSums(.)
geneList[["noresponse"]] <- names(geneList[["noresponse"]][which(geneList[["noresponse"]] != 0)])

kegglist <- list()
kegglist[["response"]] <- kegg_SYMBOL_hsa(genes = geneList[["response"]])
barplot(kegglist[["response"]])
kegglist[["noresponse"]] <- kegg_SYMBOL_hsa(genes = geneList[["noresponse"]])
barplot(kegglist[["noresponse"]])
```

## RNA-Seq数据分析

```{r rna_seq_dataprep, include=FALSE}
rm(wes_snp,wes_cnv)
invisible(gc())
rna_seq_data <- read_xlsx(path = "./data/rnaseq.xlsx")

## 构建表达矩阵
group_list_complete <- merge(
  rna_seq_data %>% dplyr::select(sample_id, patient_id),
  clinic %>% dplyr::select(c("姓名", "编号","PFS_event","response","PD")),
  by.x = "patient_id",
  by.y = "编号"
) %>% unique() %>%
  magrittr::set_rownames(.$sample_id) %>%
  dplyr::select(-"sample_id") %>% unique() %>%
  rownames_to_column(var = "sample_id") %>%
  magrittr::set_rownames(.$sample_id)

uncertain_list <- group_list_complete %>%
  filter(姓名 %in% uncertain_patients) %>%
  dplyr::select(c("姓名","patient_id","sample_id"))

if(params$filter_uncertain == TRUE){
  group_list_complete <- group_list_complete %>%
    filter(姓名 %in% uncertain_patients == FALSE)
}

raw_count_matrix <- rna_seq_data %>%
  dplyr::select(sample_id, gene, count) %>%
  filter(sample_id %in% group_list_complete$sample_id) %>%
  unique() %>%
  pivot_wider(names_from = sample_id, values_from = count) %>%
  column_to_rownames(var = "gene")

## 构建TPM矩阵
tpm_matrix <- rna_seq_data %>%
  dplyr::select(sample_id, gene, tpm) %>%
  filter(sample_id %in% group_list_complete$sample_id) %>%
  unique() %>%
  pivot_wider(names_from = sample_id, values_from = tpm) %>%
  column_to_rownames(var = "gene")

## 获得log2用的标准化矩阵
tpm_log2_matrix <- rna_seq_data %>%
  mutate(tpm_log2 = log2(tpm+1)) %>%
  dplyr::select(sample_id, gene, tpm_log2) %>%
  filter(sample_id %in% group_list_complete$sample_id) %>%
  unique() %>%
  pivot_wider(names_from = sample_id, values_from = tpm_log2) %>%
  column_to_rownames(var = "gene")
if(F){
  ## 获得TIDE用的标准化矩阵
tpm_log2_matrix_tide <- tpm_log2_matrix %>% t() %>%
  scale(., center = TRUE,scale = FALSE) %>% # https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/summary-manip.html#summ-trans-standard 标准化 
  t()
write.table(rownames_to_column(as.data.frame(tpm_log2_matrix)),file = paste0("./data/pcox_tpm_exp_log2.txt"),row.names = F,quote = F,sep = "\t")
## 构建CIBERSORT矩阵
source("../../cibersort.R")
if(file.exists("./data/pcox_ciber.RData") == FALSE){
  if(file.exists("./data/pcox_tpm_exp.txt") == FALSE){
    write.table(rownames_to_column(tpm_matrix),file = paste0("./data/pcox_tpm_exp.txt"),row.names = F,quote = F,sep = "\t")
  }
  TME.results <- CIBERSORT("../../Export/CIBERSORT/LM22.txt", 
                           "./data/pcox_tpm_exp.txt", 
                           perm = 1000, 
                           QN = T)
  save(TME.results,file = "./data/pcox_ciber.RData")
}
load(file = "./data/pcox_ciber.RData")
TME.results <- TME.results[group_list_complete$sample_id,]
}

```

### 两组人群直接比较

#### 差异基因和通路

Response组值得关注的活化通路为Antigen_Presenting和Cytokine-Cytokine Interaction，还有HALLMARK_MYC和MTOR, 抑制通路HALLMARK_上皮间充质转化  
如果按照是否能持续PR分组，那么Antigen_Presenting还是存在, 还有值得关注的是KRAS_SIGNALING_DN;差异基因主要有TAPBP和FGFR1比较引人注目

```{r grouping, echo=FALSE, message=FALSE, warning=FALSE}

if(params$division_criteria == "response"){
  group <- group_list_complete[colnames(raw_count_matrix),"response"] ## response为1,因此展示的是response相对于non-response的结果
  group[group == "/"] <- "1"
  project_id = "PCOX_Response"
}else if(params$division_criteria == "pd"){
  group <- group_list_complete[colnames(raw_count_matrix),"PD"] ## response为1,因此展示的是response相对于non-response的结果
  group[group == "/"] <- "0"
  project_id = "PCOX_PD"
}else if(params$division_criteria == "benefit"){
  group <- ifelse((group_list_complete$response == "1" & group_list_complete$PD == "0"),"1","0")
  project_id <- "PCOX_Benefit"
}

if(params$filter_uncertain == TRUE){
  project_id <- paste0(project_id,"_filtereduncertain")
}

pdata_group <- data.frame(ID = colnames(tpm_log2_matrix), Response = as.factor(group))
```


```{r dea,fig.height=8}
coad_degs <- read.table("./data/coad_table_degenes.txt", header = TRUE, sep = "\t")
coad_surv <- read.table("./data/coad_table_survival.txt", header = TRUE, sep = "\t")

### PCA查看异质性
data.pca <- prcomp(t(raw_count_matrix[which(apply(raw_count_matrix, 1, var)!=0), ]), scale. = T)
library(factoextra)
fviz_pca_ind(data.pca,
             col.ind=group,
             mean.point=F,
             addEllipses = T, 
             legend.title="Groups",
             ellipse.type="confidence",
             ellipse.level=0.9,
             palette = c("#CC3333", "#339999"))+ #Cell配色哦
  theme(panel.border = element_rect(fill=NA,color="black", size=1, linetype="solid"))

data.pca_tpm <- prcomp(t(tpm_matrix[which(apply(tpm_matrix, 1, var)!=0), ]), scale. = T)
fviz_pca_ind(data.pca_tpm,
             col.ind=group,
             mean.point=F,
             addEllipses = T, 
             legend.title="Groups",
             ellipse.type="confidence",
             ellipse.level=0.9,
             palette = c("#CC3333", "#339999"))+ #Cell配色哦
  theme(panel.border = element_rect(fill=NA,color="black", size=1, linetype="solid"))

if(params$pipeline == "edger"){
  library(edgeR)
  dgelist <- DGEList(counts = as.matrix(raw_count_matrix), group = group)
  ### 过滤低表达量基因
  keep <- rowSums(cpm(dgelist) > 1 ) >= 2
  dgelist <- dgelist[keep, , keep.lib.sizes = FALSE]
  ###  TMM 标准化
  dgelist$samples$lib.size <- colSums(dgelist$counts)
  dgelist_norm <- calcNormFactors(dgelist, method = 'TMM')
  design <- model.matrix(~0+group)
  rownames(design)<-colnames(dgelist)
  colnames(design)<-levels(group)
  ### 估算基因表达值的离散度
  dge <- estimateDisp(dgelist_norm, design)
  ### 模型拟合,出结果
  fit <- glmFit(dge, design)     #拟合模型
  lrt <- glmLRT(fit,contrast=c(-1,1))   #统计检验
  knitr::kable(topTags(lrt))
  dge_de <- decideTestsDGE(lrt, adjust.method = 'fdr', p.value = 0.05)
  summary(dge_de)
  DEG <- data.frame(topTags(lrt, n = nrow(lrt$table)))
  DEG$padj <- DEG$FDR
  threshold<-as.factor((DEG$logFC>1|DEG$logFC<(-1)) & DEG$FDR<0.05)
  DEG_sig <- DEG[which(threshold == TRUE),]
  ggplot(data = DEG,aes(x= logFC,
                        y= -1*log10(FDR),colour=as.factor((DEG$logFC>1|DEG$logFC<(-1)) & DEG$FDR<0.05)))+xlab("log2 fold-change")+ylab("-log10 p-value")+geom_point()
  coad_degs_degsig <- intersect(rownames(DEG_sig), coad_degs$Gene.Symbol)
  coad_degs_surv <- intersect(rownames(DEG_sig), coad_surv$Gene.Symbol)
  write_xlsx(list("deg" = data.frame(topTags(lrt, n=nrow(dge))) %>% rownames_to_column(),
                  "deg_tcgadeg" = DEG_sig[coad_degs_degsig,]%>% rownames_to_column(var = "gene"),
                  "deg_surv" = DEG_sig[coad_degs_surv,]%>% rownames_to_column(var = "gene")), path = paste0("./output/",project_id,"/DEGs",project_id,"_edgeR.xlsx"), use_zip64 = TRUE)
  gene_list <- lrt$table %>%
    arrange(desc(logFC)) %>%
    dplyr::select(c("logFC")) # 此时Row Name已经是基因了, 虽然不知道为什么
}else if(params$pipeline == "deseq2"){
  library(DESeq2)
  dds <- DESeqDataSetFromMatrix(countData = raw_count_matrix[rowMeans(raw_count_matrix) > 1,], colData = data.frame(group = group), design = ~group)
  # vsd <- assay(vst(dds, blind = FALSE))
  dds <- DESeq(dds, parallel = TRUE)
  res <- results(dds)
  resOrdered <- res[order(res$pvalue),]
  DEG <- as.data.frame(resOrdered)
  threshold<-as.factor((DEG$log2FoldChange>1|DEG$log2FoldChange<(-1)) & DEG$pvalue<0.05)
  print(ggplot(data = DEG[-1,],aes(x= log2FoldChange,
                                   y= -1*log10(DEG$pval[-1]),colour=threshold[-1]))+xlab("log2 fold-change")+ylab("-log10 p-value")+geom_point())
  DEG_sig <- DEG[which(threshold == TRUE),]
  coad_degs_degsig <- intersect(rownames(DEG_sig), coad_degs$Gene.Symbol)
  coad_degs_surv <- intersect(rownames(DEG_sig), coad_surv$Gene.Symbol)
  write_xlsx(list("deg" = DEG %>% rownames_to_column(var = "gene"),
                  "deg_tcgadeg" = DEG_sig[coad_degs_degsig,]%>% rownames_to_column(var = "gene"),
                  "deg_surv" = DEG_sig[coad_degs_surv,]%>% rownames_to_column(var = "gene")), path = paste0("./output/",project_id,"/DEGs",project_id,"_deseq2.xlsx"), use_zip64 = TRUE)
  gene_list <- DEG %>%
    arrange(desc(log2FoldChange)) %>%
    dplyr::select("log2FoldChange")
}
knitr::kable(head(DEG_sig,n = 30))
knitr::kable(head(DEG_sig[coad_degs_degsig,],n = 30))
knitr::kable(DEG_sig[coad_degs_surv,])
knitr::kable(DEG_sig[intersect(coad_degs_degsig,coad_degs_surv),])
# tinyarray::draw_heatmap(tpm_log2_matrix[coad_degs_degsig,setdiff(colnames(tpm_matrix), "TKGH9921R-RT")],group[1:(length(group)-1)],show_rownames = TRUE, split_column = TRUE, scale = TRUE)
tinyarray::draw_heatmap(tpm_log2_matrix[coad_degs_degsig,],group,show_rownames = TRUE, split_column = TRUE, scale = TRUE)
tinyarray::draw_heatmap(tpm_log2_matrix[rownames(DEG_sig),],group,show_rownames = FALSE, split_column = TRUE, scale = TRUE)
tinyarray::draw_heatmap(tpm_log2_matrix[rownames(DEG%>% filter(abs(logFC)>=0.5 & PValue <= 0.05)),],group,show_rownames = FALSE, split_column = TRUE, scale = TRUE)
tinyarray::draw_heatmap(tpm_log2_matrix[coad_degs_surv,],group,show_rownames = TRUE, split_column = TRUE, scale = TRUE)
tinyarray::draw_heatmap(tpm_matrix[c("MMP10","ERBB2"),],group,show_rownames = TRUE, split_column = TRUE, scale = TRUE)


tinyarray::exp_surv(tpm_log2_matrix[c("MMP10","ERBB2","TAPBP", "IFNG", "GZMA", "GZMB", "IDO1", "LAG3", "PTEN"),], meta = data.frame(
  sample = clinic$RNA_FILE,
  time = clinic$PFS,
  event = clinic$PFS_event
))


exp_surv_mod <- function (exprSet_hub, meta, color = c("grey", "red"), use_median = FALSE) 
{
  cut.point = point_cut(exprSet_hub, meta)
  splots <- lapply(rownames(exprSet_hub), function(g) {
    i = which(rownames(exprSet_hub) == g)
    meta$gene = ifelse(as.numeric(exprSet_hub[g, ]) > cut.point[[i]], 
                       "high", "low")
    if(use_median){
      meta$gene = ifelse(as.numeric(exprSet_hub[g, ]) > median(as.numeric(exprSet_hub[g, ])), 
                       "high", "low")
    }
    if (length(unique(meta$gene)) == 1) 
      stop(paste0("gene", g, "with too low expression"))
    sfit1 = survival::survfit(survival::Surv(time, event) ~ 
                                gene, data = meta)
    p = survminer::ggsurvplot(
      sfit1, pval = TRUE, 
      # palette = rev(color), 
      legend.title = "TAPBP Expression",
      legend.labs = c("High","Low"),
      risk.table = TRUE,
      data = meta, 
      ylab = "Tumor-Specific Progressive Free Survival",
      # legend = c(0.8, 0.8), 
      risk.table.y.text = FALSE,
      risk.table.y.text.col = TRUE,
      risk.table.title = element_blank(),
      risk.table.pos = "in",
      palette = "npg",
      break.time.by = 6,
      censor.size = 2.5,
      cumcensor = TRUE,
      cumcensor.y.text = FALSE,
      cumcensor.y.text.col = TRUE,
      pval.method = TRUE,
      cumcensor.height = 0.2,
      risk.table.height = 0.2,
      # pval.size = 2,
      conf.int = TRUE,         # show confidence intervals for 
      # point estimaes of survival curves.
      size = 0.65, # 控制线条粗细
      # font.x = c(6, "bold", "Black"),
      # font.y = c(6, "bold", "Black"),
      # font.title = c(8, "bold", "Black"),
      # risk.table.fontsize = 2,
      # fontsize = 1.6,
      # fontsize = 2,
      # font.tickslab = c(6, "plain", "darkgreen"),
      # title = rownames(exprSet_hub)[[i]]
    )
    p2 = p$plot + theme(plot.title = element_text(hjust = 0.5))
    return(p)
  })
  return(splots)
}

tapbp_survplot <- exp_surv_mod(tpm_log2_matrix["TAPBP",], meta = data.frame(
  sample = clinic$RNA_FILE,
  time = clinic$PFS,
  event = as.numeric(clinic$PD)
))
# pdf(file = "./figures/Figure_h_pdf.pdf",height = 6)
# print(tapbp_survplot[[1]])
# dev.off()

tapbp_survplot_median <- exp_surv_mod(tpm_log2_matrix["TAPBP",], meta = data.frame(
  sample = clinic$RNA_FILE,
  time = clinic$PFS,
  event = as.numeric(clinic$PD)
), use_median = TRUE)
pdf(file = "./figures/Figure_h_median.pdf",height = 6)
print(tapbp_survplot_median[[1]])
dev.off()

library(patchwork)
tapbp_plot_rebind <- tapbp_survplot[[1]]$plot / (tapbp_survplot[[1]]$table+theme(title = element_blank(), plot.margin = unit(c(0,0,0,0),"mm"), axis.line = element_blank(), axis.ticks = element_blank(), axis.text.x = element_blank(), axis.title.x = element_blank() ,axis.title.y = element_blank())) / (tapbp_survplot[[1]]$cumevents + theme(title = element_blank(), plot.margin = unit(c(0,0,0,0),"mm"), axis.line = element_blank(), axis.ticks = element_blank(), axis.text.x = element_blank(), axis.title.x = element_blank() ,axis.title.y = element_blank()))+plot_layout(heights = c(10,2,2))  & theme(legend.text = element_text(size = 6),legend.title = element_text(size = 6))
# ggsave(filename = "Figure_h.pdf",plot = tapbp_plot_rebind, path = "./figures", units = "cm", width = 12, height = 10)
```

```{r gsea_response, echo=FALSE, message=FALSE, warning=FALSE,fig.keep='all',fig.width=12,fig.height=8}
gene_id <- bitr(
  rownames(gene_list), fromType = "SYMBOL",
  toType = "ENTREZID",
  OrgDb = org.Hs.eg.db
)
# gene_list_original <- gene_list
gene_list_new <- (gene_list[gene_id$SYMBOL,])
names(gene_list_new) <- as.character(gene_id$ENTREZID)
gsea_res <- list()
# names(gene_list_original) <- as.character(gene_id$SYMBOL)
gsea_res[["go2"]] <- clusterProfiler::simplify(gseGO(
  geneList     = gene_list_new,
  OrgDb        = org.Hs.eg.db,
  ont          = "ALL",
  minGSSize    = 10,
  maxGSSize    = 500,
  pvalueCutoff = 0.05,
  verbose      = TRUE
))
gsea_res[["kegg2"]] <- gseKEGG(
  geneList = gene_list_new,
  organism     = "hsa",
  minGSSize    = 10,
  pvalueCutoff = 0.05,
  verbose      = TRUE
)
if(nrow(gsea_res[["go2"]]@result) != 0){
  go2plot <- dotplot(gsea_res[["go2"]], split = ".sign", font.size = 6, showCategory=30) + facet_grid(~.sign)
  print(go2plot)
}
if(nrow(gsea_res[["kegg2"]]@result) != 0){
  kegg2plot <- dotplot(gsea_res[["kegg2"]], split = ".sign", font.size = 8, showCategory=15) + facet_grid(~.sign)
  print(kegg2plot)
  kegg2_ridge <- ridgeplot(gsea_res[["kegg2"]],label_format = 50)
  print(kegg2_ridge)
  edox2 <- pairwise_termsim(gsea_res[["kegg2"]])
  print(treeplot(edox2))
  keggcnetplot_all <- cnetplot(setReadable(gsea_res[["kegg2"]], 'org.Hs.eg.db',keyType = 'ENTREZID'), foldChange=gene_list_new)
  keggcnetplot_apm <- cnetplot(setReadable(gsea_res[["kegg2"]], 'org.Hs.eg.db',keyType = 'ENTREZID'), foldChange=gene_list_new, showCategory = c("Antigen processing and presentation", "Wnt signaling pathway", "Viral protein interaction with cytokine and cytokine receptor"))
  print(keggcnetplot_all)
  print(keggcnetplot_apm)
  emapplot(
    pairwise_termsim(gsea_res[["kegg2"]]),
    showCategory = 20,
    color = "p.adjust",#设置颜色，也可以用pvalue, qvalue
    layout = "sphere",##布局
    pie_scale = 1,#点大小
    line_scale = 1#线条粗细
  )
}
print(gseaplot2(gsea_res[["kegg2"]], "hsa04612", title = "Antigen processing and presentation",base_size = 8, pvalue_table = TRUE))
# gseaplot2(gsea_res[["kegg2"]], "hsa04024", title = "cAMP signaling pathway",base_size = 8, pvalue_table = TRUE)
# gseaplot2(gsea_res[["kegg2"]], "hsa04216", title = "Ferroptosis",base_size = 8, pvalue_table = TRUE)
print(gseaplot2(gsea_res[["kegg2"]], "hsa04310", title = "Wnt signaling pathway",base_size = 8, pvalue_table = TRUE))
print(gseaplot2(gsea_res[["kegg2"]], "hsa04060", title = "Viral protein interaction with cytokine and cytokine receptor",base_size = 8, pvalue_table = TRUE))
# gseaplot2(gsea_res[["kegg2"]], "hsa04066", pvalue_table = TRUE)
## 尝试MSigDB HALLMARK聚类
# gmt <- read.gmt("../../GSEA/h.all.v7.4.entrez.gmt") #读gmt文件
hallmark_gmt <- msigdbr(species = "Homo sapiens", category = "H") %>% 
  dplyr::select(gs_name, entrez_gene)
gsea_res[["hallmark"]] <- GSEA(
  gene_list_new,
  pvalueCutoff = 0.05,
  TERM2GENE = hallmark_gmt) #GSEA分析
# head(gsea_res[["hallmark"]]@result)
if(nrow(gsea_res[["hallmark"]]@result) != 0){
  hallmarkplot <- dotplot(gsea_res[["hallmark"]], split = ".sign", font.size = 8, showCategory=30) + facet_grid(~.sign)
  print(hallmarkplot)
  hallmark_ridge <- ridgeplot(gsea_res[["hallmark"]])
  print(hallmark_ridge)
  edox2 <- pairwise_termsim(gsea_res[["hallmark"]])
  print(treeplot(edox2))
  print(cnetplot(setReadable(gsea_res[["hallmark"]], 'org.Hs.eg.db',keyType = 'ENTREZID'), foldChange=gene_list_new, showCategory = c("HALLMARK_MTORC1_SIGNALING", "HALLMARK_MYC_TARGETS_V2","HALLMARK_MYC_TARGETS_V1","HALLMARK_ANGIOGENESIS")))
}
# gseaplot2(gsea_res[["hallmark"]], "HALLMARK_UNFOLDED_PROTEIN_RESPONSE", title = "HALLMARK_UNFOLDED_PROTEIN_RESPONSE",base_size = 8, pvalue_table = TRUE)
# gseaplot2(gsea_res[["hallmark"]], "HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION", title = "HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION",base_size = 8, pvalue_table = TRUE)
print(gseaplot2(gsea_res[["hallmark"]], "HALLMARK_OXIDATIVE_PHOSPHORYLATION", title = "HALLMARK_OXIDATIVE_PHOSPHORYLATION",base_size = 8, pvalue_table = TRUE))
print(gseaplot2(gsea_res[["hallmark"]], "HALLMARK_MTORC1_SIGNALING", title = "HALLMARK_MTORC1_SIGNALING",base_size = 8, pvalue_table = TRUE))
# gseaplot2(gsea_res[["hallmark"]], "HALLMARK_ANGIOGENESIS", title = "HALLMARK_ANGIOGENESIS",base_size = 8, pvalue_table = TRUE)
gseaplot2(gsea_res[["hallmark"]], c("HALLMARK_MYC_TARGETS_V2","HALLMARK_MYC_TARGETS_V1"),base_size = 8, pvalue_table = TRUE)
## 尝试ReactomePA聚类
gsea_res[["reactome"]] <- gsePathway(
  geneList = gene_list_new,
  organism = "human",
  pvalueCutoff = 0.1,
  pAdjustMethod = "BH", 
  verbose = FALSE
)
if(nrow(gsea_res[["reactome"]]@result) != 0){
  paplot <- dotplot(gsea_res[["reactome"]], split = ".sign", font.size = 8, showCategory=30, label_format = 60) + facet_grid(~.sign)
  print(paplot)
  ridgeplot(gsea_res[["reactome"]],label_format = 60)
  edox2 <- pairwise_termsim(gsea_res[["reactome"]])
  print(treeplot(edox2))
  # concerned_pathways <- unique(c("R-HSA-168898","R-HSA-6802952","R-HSA-6802949","R-HSA-6802946","R-HSA-9649948","R-HSA-6802948","R-HSA-1236975","R-HSA-166016","R-HSA-168188","R-HSA-168179","R-HSA-389948","R-HSA-1236975","R-HSA-8950505","R-HSA-9020591"))
  # if(length(intersect(x = concerned_pathways, y = gsea_res[["reactome"]]@result$ID))!=0){
  #   print(gseaplot2(x = gsea_res[["reactome"]], geneSetID = intersect(concerned_pathways, gsea_res[["reactome"]]@result$ID),pvalue_table = TRUE,base_size = 8))
  # }
  # cnetplot(gsea_res[["reactome"]]@result, foldChange=gene_list_new, circular = TRUE, colorEdge = TRUE)
}
c2_gmt <- msigdbr::msigdbr(species = "Homo sapiens", category = "C2") %>%
  dplyr::select(gs_name, entrez_gene)
gsea_res[["c2"]] <- GSEA(
  gene_list_new,
  pvalueCutoff = 0.1,
  TERM2GENE = c2_gmt) #GSEA分析
## 尝试经典的通路聚类法
DEG_sig <- bitr(rownames(DEG %>% filter(padj <= 0.05)),
                fromType = "SYMBOL",
                toType = "ENTREZID",
                OrgDb = org.Hs.eg.db
)
go_enrich <- clusterProfiler::simplify(enrichGO(gene = DEG_sig$ENTREZID, OrgDb = org.Hs.eg.db,ont = "ALL"))
if(is.null(go_enrich) == FALSE){
  if(nrow(go_enrich@result) != 0){
    barplot(go_enrich)
  }
}
kegg_enrich <- enrichKEGG(gene = DEG_sig$ENTREZID)
if(is.null(kegg_enrich) == FALSE){
  if(nrow(kegg_enrich@result) != 0){
    barplot(kegg_enrich)
  }
}
hallmark_enrich <- enricher(gene = DEG_sig$ENTREZID, TERM2GENE = hallmark_gmt)
if(is.null(hallmark_enrich) == FALSE){
  if(nrow(hallmark_enrich@result) != 0){
    barplot(hallmark_enrich)
  }
}
reactome_enrich <- enrichPathway(gene = DEG_sig$ENTREZID)
if(is.null(reactome_enrich) == FALSE){
  if(nrow(reactome_enrich@result) != 0){
    barplot(reactome_enrich)
  }
}

writexl::write_xlsx(x = list(
  "go" = gsea_res[["go2"]]@result,
  "kegg" = gsea_res[["kegg2"]]@result,
  "hallmark" = gsea_res[["hallmark"]]@result,
  "reactome" = gsea_res[["reactome"]]@result,
  "c2" = gsea_res[["c2"]]@result
),path = paste0("./output/",project_id,"/PathwayEnrichment_",project_id,"_",params$pipeline, ".xlsx"),
use_zip64 = TRUE)

library(CBNplot)
library(DESeq2)
rescale.AsIs <- function(x, ...){
  # 自定义dropAsis方法
  dropAsis <- function(x){
    cls <- class(x)
    structure(x, class = setdiff(cls, "AsIs"))
  }
  # 调用本来的rescale方法
  scales:::rescale(dropAsis(x), ...)
}
dds <- DESeqDataSetFromMatrix(countData = raw_count_matrix[rowMeans(raw_count_matrix) > 1,], colData = data.frame(group = group), design = ~group)
vsted <- assay(vst(dds, blind = FALSE))
vsted_ensembl <- bitr(rownames(vsted), fromType = "SYMBOL", toType = "ENSEMBL", OrgDb = org.Hs.eg.db)
vsted_mapped <- vsted[vsted_ensembl$SYMBOL,]
rownames(vsted_mapped) <- vsted_ensembl$ENSEMBL
bnpathplot(results = setReadable(gsea_res[["kegg2"]], OrgDb = org.Hs.eg.db, keyType = "ENTREZID"),
           exp = vsted_mapped,
           nCategory = 15,
           R = 10,
           expRow = "ENSEMBL",
           shadowText = TRUE,
           color = "enrichmentScore",
           orgDb = org.Hs.eg.db)
kegg_readable <- setReadable(gsea_res[["kegg2"]], OrgDb = org.Hs.eg.db, keyType = "ENTREZID")
write_xlsx(kegg_readable@result, path = "./figures/kegg.xlsx")

```

~~ #### 免疫浸润 ~~

```{r response_immune,eval=FALSE}
re <- TME.results[,-(23:25)]
## 删除一半样本中丰度为0的免疫细胞
k <- apply(re,2,function(x) {sum(x == 0) < nrow(TME.results)/2}) # sum(TRUE)是1,FALSE是0,有几个TRUE就是几
table(k)
re2 <- as.data.frame(t(re[,k]))[,group_list_complete$sample_id]
an <- data.frame(
  group = group,
  row.names = colnames(re2)
) %>% 
  arrange(desc(group))
pheatmap(re2[,rownames(an)],
         show_colnames = T,
         cluster_cols = T,
         annotation_col = an,
         color = colorRampPalette(c("navy", "white", "firebrick3"))(50))
pheatmap(re2[,rownames(an)],
         scale = "row",
         show_colnames = T,
         cluster_cols = T,
         annotation_col = an,
         color = colorRampPalette(c("navy", "white", "firebrick3"))(50))
dat <- re %>% as.data.frame() %>%
  rownames_to_column("Sample") %>%
  mutate(Group = an[Sample,]) %>%
  gather(key = Cell_type,value = Proportion,-Sample,-Group)
dat$Group <- as.factor(dat$Group)
ggplot(dat[which(is.na(dat$Group) == FALSE),],aes(Cell_type,Proportion,fill = Group)) + 
  geom_boxplot(outlier.shape = 21,color = "black") + 
  theme_bw() + 
  labs(x = "Cell Type", y = "Estimated Proportion") +
  theme(legend.position = "top") + 
  theme(axis.text.x = element_text(angle=80,vjust = 0.5))+
  stat_compare_means(aes(group = Group,label = ..p.signif..),method = "wilcox.test") # ggpubr包的功能
```

#### GSVA/ssGSEA分析
  
ssGSEA主要关注免疫浸润的结果,尤其是Benefit分组人群里的CD56 NK和Th17细胞的结果,似乎与分组比较相关

```{r gsva,fig.width=12,fig.height=8,results = 'asis'}
library(GSVA)
library(limma)
gsva_res <- list()
c2gmt_original <- msigdbr::msigdbr(species = "Homo sapiens", category = "C2")
c2gmt <- c2gmt_original[grep("^REACTOME|BIOCARTA", c2gmt_original$gs_name),]
c2gmt_list <- split(c2gmt$gene_symbol,c2gmt$gs_name)
gsva_res[["c2"]] <- gsva(as.matrix(tpm_log2_matrix), c2gmt_list,mx.diff=FALSE, verbose=FALSE,parallel.sz=2, method = "ssgsea")
gsva_res[["c2_raw"]] <- gsva(as.matrix(raw_count_matrix), c2gmt_list,mx.diff=FALSE, verbose=FALSE,parallel.sz=2,kcdf = "Poisson")
kegggmt <- c2gmt_original[grep("^KEGG", c2gmt_original$gs_name),]
kegg_list <- split(kegggmt$gene_symbol,kegggmt$gs_name)
gsva_res[["kegg"]] <- gsva(as.matrix(tpm_log2_matrix), kegg_list,mx.diff=FALSE, verbose=FALSE,parallel.sz=2, method = "ssgsea")
gsva_res[["kegg_raw"]] <- gsva(as.matrix(raw_count_matrix), kegg_list,mx.diff=FALSE, verbose=FALSE,parallel.sz=2,kcdf = "Poisson")
hgmt <- msigdbr::msigdbr(species = "Homo sapiens", category = "H")
hgmt_list <- split(hgmt$gene_symbol,hgmt$gs_name)
gsva_res[["hallmark"]] <- gsva(as.matrix(tpm_log2_matrix), hgmt_list,mx.diff=FALSE, verbose=FALSE,parallel.sz=2, method = "ssgsea")
gsva_res[["hallmark_raw"]] <- gsva(as.matrix(raw_count_matrix), hgmt_list,mx.diff=FALSE, verbose=FALSE,parallel.sz=2,kcdf = "Poisson")
immune_gmt <- read.csv("./data/ssGSEA_immune.csv")
immune_gmt_list <- split(as.matrix(immune_gmt)[,1], immune_gmt[,2])
gsva_res[["immune"]] <- gsva(as.matrix(tpm_log2_matrix), immune_gmt_list, mx.diff=FALSE, verbose=FALSE, parallel.sz=2, method = "ssgsea")
design = model.matrix(~group)
lapply(gsva_res, function(gsva_x){
  fit = lmFit(gsva_x, design)
  fit = eBayes(fit)
  DEG = topTable(fit, coef = 2, number = Inf)
  print(knitr::kable(head(DEG,20)))
  # if(sum(abs(DEG$logFC) >= 0.5 & DEG$P.Value <= 0.05)>0){
  #   print(tinyarray::draw_volcano(DEG,pkg = 4,logFC_cutoff = 0.5))
  # }
  tinyarray::draw_heatmap(gsva_x[head(rownames(DEG),20),],group,show_rownames = TRUE, split_column = TRUE,show_column_title = TRUE, color = (colorRampPalette(rev(RColorBrewer::brewer.pal(n = 5, name = "RdYlBu"))))(100), color_an = palettes(category = "box", palette = "nrc", 
        show_col = FALSE, show_message = FALSE))
  # print(tinyarray::draw_pca(gsva_x,group))
})



```

## decoupleR和Progency通路分析
```{r decoupler}
library(progeny)
library(decoupleR)
library(tidyHeatmap)
library(tinyarray)
model <- progeny::model_human_full
model_top100 <- progeny::getModel("Human", top=100)

## 数据预处理
if(exists("dds") == FALSE){
  library(DESeq2)
  dds <- DESeqDataSetFromMatrix(countData = raw_count_matrix[rowMeans(raw_count_matrix) > 1,], colData = data.frame(group = group), design = ~group)
}else if(nrow(dds@colData) != ncol(raw_count_matrix)){
  library(DESeq2)
  dds <- DESeqDataSetFromMatrix(countData = raw_count_matrix[rowMeans(raw_count_matrix) > 1,], colData = data.frame(group = group), design = ~group)
}
dset <- estimateSizeFactors(dds)
dset <- estimateDispersions(dset)
gene_expr <- getVarianceStabilizedData(dset)
names(group) <- colnames(raw_count_matrix)

pathway_matrix <- progeny(expr = as.matrix(tpm_log2_matrix), scale=TRUE,
                    organism="Human",
                    top = 500, perm = 1)

pathway_matrix_heatmap <- pathway_matrix %>% 
  as.data.frame() %>%
  as_tibble(rownames = "Tumor_Sample_Barcode") %>%
  pivot_longer(cols = any_of(colnames(pathway_matrix)), values_to = "Activity", names_to = "Pathway") %>%
  mutate(Group = group[Tumor_Sample_Barcode]) %>%
  group_by(Group) %>%
  heatmap(
    .row = Pathway,
    .column = Tumor_Sample_Barcode,
    .value = Activity,
    palette_value = c("darkblue", "white","red"),
    palette_grouping = list(c("green","yellow"))
  )
print(pathway_matrix_heatmap)

ggplot(pathway_matrix_heatmap@data,aes(x = Pathway, y = Activity,fill = Group)) + 
  geom_boxplot(outlier.shape = 21,color = "black") + 
  theme_bw() + 
  labs(x = "Pathway", y = "Activity") +
  theme(legend.position = "top") + 
  theme(axis.text.x = element_text(angle=80,vjust = 0.5))+
  stat_compare_means(aes(group = Group,label = after_stat(p.signif)),method = "wilcox.test")

exp_surv(
  exprSet_hub = t(pathway_matrix)[,clinic_raw_rna$Tumor_Sample_Barcode[which(is.na(clinic_raw_rna$PFS) == FALSE)]],
  meta = data.frame(
    sample = clinic_raw_rna$Tumor_Sample_Barcode[which(is.na(clinic_raw_rna$PFS) == FALSE)],
    event = clinic_raw_rna$FSTLINE_VITAL_STATUS[which(is.na(clinic_raw_rna$PFS) == FALSE)],
    time = clinic_raw_rna$PFS[which(is.na(clinic_raw_rna$PFS) == FALSE)]
  )
)
# patchwork::wrap_plots(pathway_surv)

pathway_matrix <- progeny(expr = as.matrix(gene_expr), scale=TRUE,
                    organism="Human",
                    top = 500, perm = 1)

pathway_matrix_heatmap <- pathway_matrix %>% 
  as.data.frame() %>%
  as_tibble(rownames = "Tumor_Sample_Barcode") %>%
  pivot_longer(cols = any_of(colnames(pathway_matrix)), values_to = "Activity", names_to = "Pathway") %>%
  mutate(Group = group[Tumor_Sample_Barcode]) %>%
  group_by(Group) %>%
  heatmap(
    .row = Pathway,
    .column = Tumor_Sample_Barcode,
    .value = Activity,
    palette_value = c("darkblue", "white","red"),
    palette_grouping = list(c("yellow","green"))
  )
print(pathway_matrix_heatmap)

ggplot(pathway_matrix_heatmap@data,aes(x = Pathway, y = Activity,fill = Group)) + 
  geom_boxplot(outlier.shape = 21,color = "black") + 
  theme_bw() + 
  labs(x = "Pathway", y = "Activity") +
  theme(legend.position = "top") + 
  theme(axis.text.x = element_text(angle=80,vjust = 0.5))+
  stat_compare_means(aes(group = Group,label = after_stat(p.signif)),method = "wilcox.test")

exp_surv(
  exprSet_hub = t(pathway_matrix)[,clinic_raw_rna$Tumor_Sample_Barcode[which(is.na(clinic_raw_rna$PFS) == FALSE)]],
  meta = data.frame(
    sample = clinic_raw_rna$Tumor_Sample_Barcode[which(is.na(clinic_raw_rna$PFS) == FALSE)],
    event = clinic_raw_rna$FSTLINE_VITAL_STATUS[which(is.na(clinic_raw_rna$PFS) == FALSE)],
    time = clinic_raw_rna$PFS[which(is.na(clinic_raw_rna$PFS) == FALSE)]
  )
)

## 按照要求选用 limma 差异分析
group_list <- factor(ifelse(group == 1, "R", "NR"), ordered = TRUE, levels = c("NR","R"))
design = model.matrix(~0+factor(group_list))
colnames(design)=levels(factor(group_list))
rownames(design)=colnames(tpm_matrix)
if(exists("dgelist_norm") == FALSE){
  library(edgeR)
  dgelist <- DGEList(counts = as.matrix(raw_count_matrix), group = group)
  ### 过滤低表达量基因
  keep <- rowSums(cpm(dgelist) > 1 ) >= 2
  dgelist <- dgelist[keep, , keep.lib.sizes = FALSE]
  ###  TMM 标准化
  dgelist$samples$lib.size <- colSums(dgelist$counts)
  dgelist_norm <- calcNormFactors(dgelist, method = 'TMM')
}

de <- voom(dgelist_norm,design,plot=FALSE, normalize="quantile")
fit = lmFit(de, design)
contrast.matrix<-makeContrasts("R-NR",
                               levels = design)
fit2 <- contrasts.fit(fit, contrast.matrix)
fit3 = eBayes(fit2, trend = FALSE)
res <- decideTests(fit3, p.value = 0.05)
summary(res)
DEG_limma_voom <- na.omit(topTable(fit3, number = Inf))

deg_t <- DEG_limma_voom %>%
  rownames_to_column("ID") %>%
  select(ID, t) %>% 
  filter(!is.na(t)) %>% 
  column_to_rownames(var = "ID") %>%
  as.matrix()

# net_model <- model %>%
#   group_by(pathway) %>%
#   slice_min(order_by = p.value, n = 100) %>%
#   mutate(source = pathway, target = gene, p_value = p.value) %>%
#   ungroup() %>%
#   dplyr::select(source, target, weight, p_value) %>%
#   as_tibble()

net_model <- get_progeny(organism = 'human', top = 100)

contrast_acts <- run_wmean(mat = deg_t, net = net_model, .source='source', .target='target',
                  .mor='weight', times = 100, minsize = 5)

# Filter norm_wmean
f_contrast_acts <- contrast_acts %>%
  filter(statistic == 'norm_wmean')

# Plot
ggplot(f_contrast_acts, aes(x = reorder(source, score), y = score)) + 
    geom_bar(aes(fill = score), stat = "identity") +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) + 
    theme_minimal() +
    theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
            element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
    xlab("Pathways")

```


~~ #### APM相关基因LASSO回归 ~~

```{r lasso_apm, echo=FALSE,eval=FALSE,include=FALSE}
library(glmSparseNet)
library(IOBR)
ydata <- group
xdata <- as.matrix(t(tpm_log2_matrix)) 
xdata <- xdata[,which(apply(xdata, 2, var)!=0)]# 过滤标准差为0的基因
xdata <- xdata[,which(apply(xdata,2,function(x){
  return(sum(x == 0))
})<= nrow(xdata)/2)]

apm_genes <- unique(c(signature_collection$APM,kegg$KEGG_ANTIGEN_PROCESSING_AND_PRESENTATION, signature_collection$Antigen_Processing_and_Presentation_Li_et_al))

xdata <- xdata[,intersect(colnames(xdata), apm_genes)]

fitted <- cv.glmHub(xdata,
                    ydata,
                    family = "binomial",
                    lambda = buildLambda(1),
                    nlambda = 1000,
                    network = "correlation",
                    network.options = networkOptions(
                      cutoff = .6,
                      min.degree = .2
                    )
)
coefs.v_lambdamin <- coef(fitted, s = "lambda.min")[, 1] %>% {
  .[. != 0]
}
genes_lasso_lambdamin <- coefs.v_lambdamin %>%
  {
    data.frame(
      gene.name = names(.),
      coefficient = .,
      stringsAsFactors = FALSE
    )
  } %>%
  arrange(gene.name)
knitr::kable(genes_lasso_lambdamin) %>%
  kableExtra::kable_styling()
plot(fitted)
resp <- predict(fitted, s = 'lambda.min', newx = xdata, type = 'class')
table(resp,ydata)

response_prob <- predict(fitted, s = 'lambda.min', newx = xdata, type = 'response')
roc_obj <- pROC::roc(ydata, as.vector(response_prob))

data.frame(TPR = roc_obj$sensitivities, FPR = 1 - roc_obj$specificities) %>%
  ggplot() +geom_line(aes(FPR,TPR), color = 2, size = 1, alpha = 0.7)+
  labs(title= sprintf("ROC curve (AUC = %f)", pROC::auc(roc_obj)),
       x = "False Positive Rate (1-Specificity)",
       y = "True Positive Rate (Sensitivity)")
```


#### IOBR包引入的相关免疫微环境分析大集合

##### IOBR Signature分析
  
按Benefit分类的两组里面差异较大的signature包括TMEscoreB_CIR,T_cell_exhaustion, HALLMARK系列和GSEA一致的是MYC V2, TPM数据体现了HAVCR2但和Raw count不符合(rawcount不是显著的),TAPBP还是很好的

```{r iobr_data_prep_signature, warning=FALSE,results='hide', fig.keep='all'}
library(IOBR)
## IOBR用的数据是 log2(TPM+1) 标准化后的表达矩阵 (tpm_log2_matrix), 且列名为样品
which(apply(tpm_log2_matrix, 1, var)==0)
## 首先推算内建的所有的signature
sig_res<-calculate_sig_score(pdata           = NULL,
                             eset            = tpm_log2_matrix[which(apply(tpm_log2_matrix, 1, var)!=0), ], # 除去全体样本中表达量一致(为0)的基因,避免 https://stackoverflow.com/questions/40315227/how-to-solve-prcomp-default-cannot-rescale-a-constant-zero-column-to-unit-var 的报错
                             signature       = signature_collection,
                             method          = "ssGSEA",
                             mini_gene_count = 2)
sig_immune<-calculate_sig_score(
  pdata           = NULL,
  eset            = tpm_log2_matrix[which(apply(tpm_log2_matrix, 1, var)!=0), ], # 除去全体样本中表达量一致(为0)的基因,避免 https://stackoverflow.com/questions/40315227/how-to-solve-prcomp-default-cannot-rescale-a-constant-zero-column-to-unit-var 的报错
  signature       = immune_gmt_list,
  method          = "ssGSEA",
  mini_gene_count = 2)
sig_hallmark<-calculate_sig_score(pdata           = NULL,
                             eset            = tpm_log2_matrix[which(apply(tpm_log2_matrix, 1, var)!=0), ],
                             signature       = hallmark,
                             method          = "ssGSEA",
                             mini_gene_count = 2)
sig_kegg<-calculate_sig_score(pdata           = NULL,
                             eset            = tpm_log2_matrix[which(apply(tpm_log2_matrix, 1, var)!=0), ],
                             signature       = kegg,
                             method          = "ssGSEA",
                             mini_gene_count = 2)
## 接着批量推算TME和免疫相关signature与response的关系
iobr_cor_plot(pdata_group           = pdata_group,
                   id1                   = "ID",
                   feature_data          = sig_res,
                   id2                   = "ID",
                   target                = NULL,
                   group                 = "Response",
                   is_target_continuous  = FALSE,
                   padj_cutoff           = 1,
                   index                 = 1,
                   category              = "signature",
                   signature_group       = sig_group,
                   ProjectID             = project_id,
                   palette_box           = "paired1",
                   palette_corplot       = "pheatmap",
                   palette_heatmap       = 2,
                   feature_limit         = 20,
                   character_limit       = 30,
                   show_heatmap_col_name = TRUE,
                   show_col              = FALSE,
                   show_plot             = TRUE,
                   path                  = paste0("./output/",project_id,"/"))
iobr_cor_plot(pdata_group           = pdata_group,
                   id1                   = "ID",
                   feature_data          = sig_immune,
                   id2                   = "ID",
                   target                = NULL,
                   group                 = "Response",
                   is_target_continuous  = FALSE,
                   padj_cutoff           = 1,
                   index                 = 1,
                   category              = "signature",
                   signature_group       = list(immune_ssgsea = names(immune_gmt_list)),
                   ProjectID             = project_id,
                   palette_box           = "paired1",
                   palette_corplot       = "pheatmap",
                   palette_heatmap       = 2,
                   feature_limit         = 20,
                   character_limit       = 30,
                   show_heatmap_col_name = TRUE,
                   show_col              = FALSE,
                   show_plot             = TRUE,
                   path                  = paste0("./figures/iobr/",project_id,"/"))
## 接着批量推算HALLMARK与response的关系
iobr_cor_plot(pdata_group           = pdata_group,
                   id1                   = "ID",
                   feature_data          = sig_hallmark,
                   id2                   = "ID",
                   target                = NULL,
                   group                 = "Response",
                   is_target_continuous  = FALSE,
                   padj_cutoff           = 1,
                   index                 = 1,
                   category              = "signature",
                   signature_group       = sig_group,
                   ProjectID             = project_id,
                   palette_box           = "paired1",
                   palette_corplot       = "pheatmap",
                   palette_heatmap       = 2,
                   feature_limit         = 26,
                   character_limit       = 30,
                   show_heatmap_col_name = TRUE,
                   show_col              = FALSE,
                   show_plot             = TRUE,
                   path                  = paste0("./output/",project_id,"/"))
iobr_cor_plot(pdata_group           = pdata_group,
                   id1                   = "ID",
                   feature_data          = tpm_log2_matrix,
                   id2                   = "ID",
                   target                = NULL,
                   group                 = "Response",
                   is_target_continuous  = FALSE,
                   padj_cutoff           = 1,
                   index                 = 1,
                   category              = "gene",
                   signature_group       = hallmark$HALLMARK_WNT_BETA_CATENIN_SIGNALING,
                   ProjectID             = project_id,
                   palette_box           = "paired1",
                   palette_corplot       = "pheatmap",
                   palette_heatmap       = 2,
                   feature_limit         = 26,
                   character_limit       = 30,
                   show_heatmap_col_name = TRUE,
                   show_col              = FALSE,
                   show_plot             = TRUE,
                   path                  = paste0("./output/",project_id,"/"))
iobr_cor_plot(pdata_group           = pdata_group,
                   id1                   = "ID",
                   feature_data          = tpm_log2_matrix,
                   id2                   = "ID",
                   target                = NULL,
                   group                 = "Response",
                   is_target_continuous  = FALSE,
                   padj_cutoff           = 1,
                   index                 = 1,
                   category              = "gene",
                   signature_group       = hallmark$HALLMARK_TGF_BETA_SIGNALING,
                   ProjectID             = project_id,
                   palette_box           = "paired1",
                   palette_corplot       = "pheatmap",
                   palette_heatmap       = 2,
                   feature_limit         = 40,
                   character_limit       = 30,
                   show_heatmap_col_name = TRUE,
                   show_col              = FALSE,
                   show_plot             = TRUE,
                   path                  = paste0("./output/",project_id,"/"))
iobr_cor_plot(pdata_group           = pdata_group,
                   id1                   = "ID",
                   feature_data          = tpm_log2_matrix,
                   id2                   = "ID",
                   target                = NULL,
                   group                 = "Response",
                   is_target_continuous  = FALSE,
                   padj_cutoff           = 1,
                   index                 = 1,
                   category              = "gene",
                   signature_group       = hallmark$HALLMARK_ANGIOGENESIS,
                   ProjectID             = project_id,
                   palette_box           = "paired1",
                   palette_corplot       = "pheatmap",
                   palette_heatmap       = 2,
                   feature_limit         = 40,
                   character_limit       = 30,
                   show_heatmap_col_name = TRUE,
                   show_col              = FALSE,
                   show_plot             = TRUE,
                   path                  = paste0("./output/",project_id,"/"))
# 查看免疫checkpoint和response的关系
iobr_cor_plot(pdata_group           = pdata_group,
                   id1                   = "ID",
                   feature_data          = tpm_log2_matrix,
                   id2                   = "ID",
                   target                = NULL,
                   group                 = "Response",
                   is_target_continuous  = FALSE,
                   padj_cutoff           = 1,
                   index                 = 1,
                   category              = "gene",
                   signature_group       = signature_collection[4],
                   ProjectID             = project_id,
                   palette_box           = "paired1",
                   palette_corplot       = "pheatmap",
                   palette_heatmap       = 2,
                   feature_limit         = 26,
                   character_limit       = 30,
                   show_heatmap_col_name = TRUE,
                   show_col              = FALSE,
                   show_plot             = TRUE,
                   path                  = paste0("./output/",project_id,"/"))
# 查看免疫checkpoint和response的关系
iobr_cor_plot(pdata_group           = pdata_group,
                   id1                   = "ID",
                   feature_data          = tpm_log2_matrix,
                   id2                   = "ID",
                   target                = NULL,
                   group                 = "Response",
                   is_target_continuous  = FALSE,
                   padj_cutoff           = 1,
                   index                 = 1,
                   category              = "gene",
                   signature_group       = list(immune_related_genes = c("IFNG", "GZMA", "GZMB", "IDO1", "LAG3", "PTEN")),
                   ProjectID             = project_id,
                   palette_box           = "paired1",
                   palette_corplot       = "pheatmap",
                   palette_heatmap       = 2,
                   feature_limit         = 26,
                   character_limit       = 30,
                   show_heatmap_col_name = TRUE,
                   show_col              = FALSE,
                   show_plot             = TRUE,
                   path                  = paste0("./figures/iobr/",project_id,"/"))
# 查看APM Signature(抗原提呈)和response的关系
iobr_cor_plot(pdata_group           = pdata_group,
                   id1                   = "ID",
                   feature_data          = tpm_log2_matrix,
                   id2                   = "ID",
                   target                = NULL,
                   group                 = "Response",
                   is_target_continuous  = FALSE,
                   padj_cutoff           = 1,
                   index                 = 1,
                   category              = "gene",
                   signature_group       = signature_collection[3],
                   ProjectID             = project_id,
                   palette_box           = "paired1",
                   palette_corplot       = "pheatmap",
                   palette_heatmap       = 2,
                   feature_limit         = 26,
                   character_limit       = 30,
                   show_heatmap_col_name = TRUE,
                   show_col              = FALSE,
                   show_plot             = TRUE,
                   path                  = paste0("./output/",project_id,"/"))
iobr_cor_plot(pdata_group           = pdata_group,
                   id1                   = "ID",
                   feature_data          = tpm_log2_matrix,
                   id2                   = "ID",
                   target                = NULL,
                   group                 = "Response",
                   is_target_continuous  = FALSE,
                   padj_cutoff           = 1,
                   index                 = 1,
                   category              = "gene",
                   signature_group       = kegg[120],
                   ProjectID             = project_id,
                   palette_box           = "paired1",
                   palette_corplot       = "pheatmap",
                   palette_heatmap       = 2,
                   feature_limit         = 26,
                   character_limit       = 30,
                   show_heatmap_col_name = TRUE,
                   show_col              = FALSE,
                   show_plot             = TRUE,
                   path                  = paste0("./output/",project_id,"/"))
iobr_cor_plot(pdata_group           = pdata_group,
                   id1                   = "ID",
                   feature_data          = tpm_log2_matrix,
                   id2                   = "ID",
                   target                = NULL,
                   group                 = "Response",
                   is_target_continuous  = FALSE,
                   padj_cutoff           = 1,
                   index                 = 1,
                   category              = "gene",
                   signature_group       = signature_collection[101],
                   ProjectID             = project_id,
                   palette_box           = "paired1",
                   palette_corplot       = "pheatmap",
                   palette_heatmap       = 2,
                   feature_limit         = 26,
                   character_limit       = 30,
                   show_heatmap_col_name = TRUE,
                   show_col              = FALSE,
                   show_plot             = TRUE,
                   path                  = paste0("./output/",project_id,"/"))
iobr_cor_plot(pdata_group           = pdata_group,
                   id1                   = "ID",
                   feature_data          = tpm_log2_matrix,
                   id2                   = "ID",
                   target                = NULL,
                   group                 = "Response",
                   is_target_continuous  = FALSE,
                   padj_cutoff           = 1,
                   index                 = 1,
                   category              = "gene",
                   signature_group       = signature_collection$MHC_Class_I,
                   ProjectID             = project_id,
                   palette_box           = "paired1",
                   palette_corplot       = "pheatmap",
                   palette_heatmap       = 2,
                   feature_limit         = 26,
                   character_limit       = 30,
                   show_heatmap_col_name = TRUE,
                   show_col              = FALSE,
                   show_plot             = TRUE,
                   path                  = paste0("./output/",project_id,"/"))
iobr_cor_plot(pdata_group           = pdata_group,
                   id1                   = "ID",
                   feature_data          = tpm_log2_matrix,
                   id2                   = "ID",
                   target                = NULL,
                   group                 = "Response",
                   is_target_continuous  = FALSE,
                   padj_cutoff           = 1,
                   index                 = 1,
                   category              = "gene",
                   signature_group       = signature_collection[60],
                   ProjectID             = project_id,
                   palette_box           = "paired1",
                   palette_corplot       = "pheatmap",
                   palette_heatmap       = 2,
                   feature_limit         = 40,
                   character_limit       = 30,
                   show_heatmap_col_name = TRUE,
                   show_col              = FALSE,
                   show_plot             = TRUE,
                   path                  = paste0("./output/",project_id,"/"))
```

~~ ##### IOBR和Signature相关突变 ~~

```{r iobr_mutation, message=FALSE, warning=FALSE,results='hide', fig.keep='all', eval=FALSE}
## 选取影响Antigen Presenting的突变
## Antigen Presenting的Signature有APM和Antigen_Processing_and_Presentation_Li_et_al
mut_snp <- construct_maf@data %>%
  mutate(ID = group_list_complete[construct_maf@data$Tumor_Sample_Barcode,"sample_id"]) %>%
  dplyr::select(-"Tumor_Sample_Barcode")
mut_list2<-make_mut_matrix(mut_data               = mut_snp,
                           category               = "snp",
                           Tumor_Sample_Barcode = "ID",
                           Hugo_Symbol = "Hugo_Symbol",
                           Variant_Classification = "Variant_Classification",
                           Variant_Type = "Variant_Type"
)
find_mutations(mutation_matrix     = mut_list2$all, 
               signature_matrix    = sig_res,
               id_signature_matrix = "ID",
               signature           = "Antigen_Processing_and_Presentation_Li_et_al",
               save_path = paste0("./output/",project_id,"/Antigen_Processing_and_Presentation_Li_et_al-relevant-mutations/"),
               min_mut_freq        = 0.01,
               plot                = TRUE,
               method              = "Wilcoxon",
               palette             = "jco",
               show_plot           = T,
               width               = 8, 
               height              = 4,
               oncoprint_group_by  = "mean",
               oncoprint_col       = "#224444",
               gene_counts         = 10)
find_mutations(mutation_matrix     = mut_list2$all, 
               signature_matrix    = sig_res,
               id_signature_matrix = "ID",
               save_path = paste0("./output/",project_id,"/APM-relevant-mutations/"),
               signature           = "APM",
               min_mut_freq        = 0.01,
               plot                = TRUE,
               method              = "Wilcoxon",
               palette             = "jco",
               show_plot           = T,
               width               = 8, 
               height              = 4,
               oncoprint_group_by  = "mean",
               oncoprint_col       = "#224444",
               gene_counts         = 10)
find_mutations(mutation_matrix     = mut_list2$all, 
               signature_matrix    = sig_kegg,
               id_signature_matrix = "ID",
               save_path = paste0("./output/",project_id,"/KEGG_ANTIGEN_PROCESSING_AND_PRESENTATION-relevant-mutations/"),
               signature           = "KEGG_ANTIGEN_PROCESSING_AND_PRESENTATION",
               min_mut_freq        = 0.01,
               plot                = TRUE,
               method              = "Wilcoxon",
               palette             = "jco",
               show_plot           = T,
               width               = 8, 
               height              = 4,
               oncoprint_group_by  = "mean",
               oncoprint_col       = "#224444",
               gene_counts         = 10)
```

##### IOBR免疫细胞浸润

```{r iobr_infiltration, message=FALSE}
quantiseq<-deconvo_tme(eset = tpm_matrix, tumor = TRUE, arrays = FALSE, scale_mrna = TRUE, method = "quantiseq")
estimate<-deconvo_tme(eset = tpm_matrix, method = "estimate")
mcp<-deconvo_tme(eset = tpm_matrix, method = "mcpcounter")
epic<-deconvo_tme(eset = tpm_matrix, method = "epic", arrays = FALSE, tumor = TRUE)
cibersort<-deconvo_tme(eset = tpm_matrix, method = "cibersort", arrays = FALSE, perm = 200)
xcell<-deconvo_tme(eset = tpm_matrix, method = "xcell",arrays = FALSE)
tme_combine<-cibersort %>% 
  inner_join(.,mcp,by       = "ID") %>% 
  inner_join(.,xcell,by     = "ID") %>%
  inner_join(.,epic,by      = "ID") %>% 
  inner_join(.,estimate,by  = "ID") %>% 
  # inner_join(.,timer,by     = "ID") %>% 
  # inner_join(.,ips,by = "ID") %>% 
  inner_join(.,quantiseq,by       = "ID")

iobr_cor_plot(pdata_group           = pdata_group,
                   id1                   = "ID",
                   feature_data          = tme_combine,
                   id2                   = "ID",
                   target                = NULL,
                   group                 = "Response",
                   is_target_continuous  = FALSE,
                   padj_cutoff           = 1,
                   index                 = 1,
                   category              = "signature",
                   signature_group       = sig_group[c(20:24)],
                   ProjectID             = project_id,
                   palette_box           = "paired1",
                   palette_corplot       = "pheatmap",
                   palette_heatmap       = 2,
                   feature_limit         = 26,
                   character_limit       = 30,
                   show_heatmap_col_name = TRUE,
                   show_col              = FALSE,
                   show_plot             = TRUE,
                   path                  = paste0("./output/",project_id,"/"))
```

##### ImmuCellAI 免疫浸润分析
```{r immucellai}
library(ImmuCellAI)
immucellai_matrix <- rbind(paste0(rep("Group", times = length(group)),group), tpm_matrix)
rownames(immucellai_matrix)[1] <- "group"
write.table(immucellai_matrix, file = paste0("./output/",project_id,"_immucellai_matrix.txt"), sep = "\t", quote = FALSE)

# 修复ImmuneAI的一些bug
if(T){
  group_content <- immucellai_matrix[1,]
  data("marker_exp")
  data("marker_exp_T")
  data("paper_marker")
  data("train_data")
  data("train_tag")
  data("compensation_matrix")
  data("immune_infiltate_marker")
  train_tag <- as.factor(train_tag)
}

immucellai_res <- ImmuCellAI_new(
  sample = immucellai_matrix,
  data_type = "rnaseq",
  group_tag = 1,response_tag = 1)
print(immucellai_res)
```

~~ ##### IOBR免疫浸润与APM的干系 ~~

```{r immune_infiltration, warning=FALSE,echo=FALSE,eval=FALSE}
pdata_group$APM_Sig <- ifelse(response_prob>=median(response_prob),"High","Low")
# pdata_group$APM <- sig_res$APM
# pdata_group$Antigen_Processing_and_Presentation_Li_et_al <- sig_res$Antigen_Processing_and_Presentation_Li_et_al
# pdata_group$KEGG_APM <- sig_kegg$KEGG_ANTIGEN_PROCESSING_AND_PRESENTATION
# pdata_group$APM_median <- ifelse(sig_res$APM >= median(sig_res$APM),"High","Low")
# pdata_group$Antigen_Processing_and_Presentation_Li_et_al_median <- ifelse(sig_res$Antigen_Processing_and_Presentation_Li_et_al >= median(sig_res$Antigen_Processing_and_Presentation_Li_et_al),"High","Low")
# pdata_group$KEGG_APM_median <- ifelse(sig_kegg$KEGG_ANTIGEN_PROCESSING_AND_PRESENTATION >= median(sig_kegg$KEGG_ANTIGEN_PROCESSING_AND_PRESENTATION),"High","Low")

tinyarray::draw_heatmap(gsva_res[["immune"]],pdata_group$APM_Sig,show_rownames = TRUE, split_column = TRUE,show_column_title = TRUE)

iobr_cor_plot(pdata_group           = pdata_group,
                   id1                   = "ID",
                   feature_data          = tme_combine,
                   id2                   = "ID",
                   target                = NULL,
                   group                 = "APM_Sig",
                   is_target_continuous  = FALSE,
                   padj_cutoff           = 1,
                   index                 = 1,
                   category              = "signature",
                   signature_group       = sig_group[c(20:22,24)],
                   ProjectID             = project_id,
                   palette_box           = "paired1",
                   palette_corplot       = "pheatmap",
                   palette_heatmap       = 2,
                   feature_limit         = 26,
                   character_limit       = 30,
                   show_heatmap_col_name = TRUE,
                   show_col              = FALSE,
                   show_plot             = TRUE,
                   path                  = paste0("./output/",project_id,"/APM_Signature-relevant-TME-cell"))

iobr_cor_plot(pdata_group           = pdata_group,
                   id1                   = "ID",
                   feature_data          = tme_combine,
                   id2                   = "ID",
                   target                = NULL,
                   group                 = "APM_median",
                   is_target_continuous  = FALSE,
                   padj_cutoff           = 1,
                   index                 = 1,
                   category              = "signature",
                   signature_group       = sig_group[c(20:22,24)],
                   ProjectID             = project_id,
                   palette_box           = "paired1",
                   palette_corplot       = "pheatmap",
                   palette_heatmap       = 2,
                   feature_limit         = 26,
                   character_limit       = 30,
                   show_heatmap_col_name = TRUE,
                   show_col              = FALSE,
                   show_plot             = TRUE,
                   path                  = paste0("./output/",project_id,"/APM-relevant-TME-cell"))

iobr_cor_plot(pdata_group           = pdata_group,
                   id1                   = "ID",
                   feature_data          = tme_combine,
                   id2                   = "ID",
                   target                = NULL,
                   group                 = "Antigen_Processing_and_Presentation_Li_et_al_median",
                   is_target_continuous  = FALSE,
                   padj_cutoff           = 1,
                   index                 = 1,
                   category              = "signature",
                   signature_group       = sig_group[c(20:22,24)],
                   ProjectID             = project_id,
                   palette_box           = "paired1",
                   palette_corplot       = "pheatmap",
                   palette_heatmap       = 2,
                   feature_limit         = 26,
                   character_limit       = 30,
                   show_heatmap_col_name = TRUE,
                   show_col              = FALSE,
                   show_plot             = TRUE,
                   path                  = paste0("./output/",project_id,"/Li_APM-relevant-TME-cell"))

iobr_cor_plot(pdata_group           = pdata_group,
                   id1                   = "ID",
                   feature_data          = tme_combine,
                   id2                   = "ID",
                   target                = NULL,
                   group                 = "KEGG_APM_median",
                   is_target_continuous  = FALSE,
                   padj_cutoff           = 1,
                   index                 = 1,
                   category              = "signature",
                   signature_group       = sig_group[c(20:22,24)],
                   ProjectID             = project_id,
                   palette_box           = "paired1",
                   palette_corplot       = "pheatmap",
                   palette_heatmap       = 2,
                   feature_limit         = 26,
                   character_limit       = 30,
                   show_heatmap_col_name = TRUE,
                   show_col              = FALSE,
                   show_plot             = TRUE,
                   path                  = paste0("./output/",project_id,"/KEGG_APM-relevant-TME-cell"))


res_apm <- iobr_cor_plot(pdata_group     = pdata_group,
                   id1                   = "ID",
                   feature_data          = tme_combine,
                   id2                   = "ID",
                   target                = "APM",
                   group                 = "group3",
                   is_target_continuous  = TRUE,
                   padj_cutoff           = 1,
                   index                 = 6,
                   category              = "signature",
                   signature_group       = sig_group[20:24],
                   ProjectID             = project_id,
                   palette_box           = "jco",
                   palette_corplot       = "pheatmap",
                   palette_heatmap       = 3,
                   feature_limit         = 26,
                   character_limit       = 30,
                   show_heatmap_col_name = TRUE,
                   show_col              = FALSE,
                   show_plot             = TRUE,
                   path                  = paste0("./output/",project_id,"/APM-relevant-TME-cell"))

res_liapm <- iobr_cor_plot(pdata_group     = pdata_group,
                   id1                   = "ID",
                   feature_data          = tme_combine,
                   id2                   = "ID",
                   target                = "Antigen_Processing_and_Presentation_Li_et_al",
                   group                 = "group3",
                   is_target_continuous  = TRUE,
                   padj_cutoff           = 1,
                   index                 = 6,
                   category              = "signature",
                   signature_group       = sig_group[20:24],
                   ProjectID             = project_id,
                   palette_box           = "jco",
                   palette_corplot       = "pheatmap",
                   palette_heatmap       = 3,
                   feature_limit         = 26,
                   character_limit       = 30,
                   show_heatmap_col_name = TRUE,
                   show_col              = FALSE,
                   show_plot             = TRUE,
                   path                  = paste0("./output/",project_id,"/Li_APM-relevant-TME-cell"))

res_keggapm <- iobr_cor_plot(pdata_group     = pdata_group,
                   id1                   = "ID",
                   feature_data          = tme_combine,
                   id2                   = "ID",
                   target                = "KEGG_APM",
                   group                 = "group3",
                   is_target_continuous  = TRUE,
                   padj_cutoff           = 1,
                   index                 = 1,
                   category              = "signature",
                   signature_group       = sig_group[20:24],
                   ProjectID             = project_id,
                   palette_box           = "jco",
                   palette_corplot       = "pheatmap",
                   palette_heatmap       = 3,
                   feature_limit         = 26,
                   character_limit       = 30,
                   show_heatmap_col_name = TRUE,
                   show_col              = FALSE,
                   show_plot             = TRUE,
                   path                  = paste0("./output/",project_id,"/KEGG_APM-relevant-TME-cell"))



```

#### BayesPrism
```{r bayesprism}
bp.res <- readRDS("./data/LINXIN_PRISM_BPRES_TP10K_dMMR.RDS")
bp_res_celltype_fraction <- get.fraction (bp=bp.res,
 which.theta="final",
 state.or.type="type") %>% as.data.frame() %>%
  rownames_to_column(var = "RNA_FILE") %>%
  filter(RNA_FILE %in% clinic$RNA_FILE)
celltypes <- setdiff(colnames(bp_res_celltype_fraction), "RNA_FILE")
bp_res_celltype_fraction_longer <- bp_res_celltype_fraction %>% 
  mutate(group = as.factor(pdata_group$Response[match(RNA_FILE, pdata_group$ID)])) %>%
  pivot_longer(cols = celltypes, names_to = "Cell Type", values_to = "Abundance") %>%
  mutate(`Cell Type` = as.factor(`Cell Type`), `Cell Fraction` = round(Abundance, digits = 3), Subtype = group)
ggplot(data = bp_res_celltype_fraction_longer %>% filter(`Cell Type` != "EpiT"), mapping = aes(x = `Cell Type`, y = `Cell Fraction`, fill = Subtype)) +
  geom_boxplot()+
  ggsci::scale_fill_jco()+
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  stat_compare_means(aes(group = group,label = after_stat(p.signif)),method = "wilcox.test")

ggplot(data = bp_res_celltype_fraction_longer %>% filter(`Cell Type` != "EpiT"), mapping = aes(x = RNA_FILE, y = Abundance, fill = `Cell Type`)) +
  geom_bar(stat="identity",position = "stack")+
  scale_fill_manual(values = IOBR::palettes(category = "random", palette = 4, 
        show_col = FALSE, show_message = T))+
  coord_flip()+
  facet_grid(rows = vars(group), scales = "free", switch = "y", space = "free_y")+
  theme(axis.text.y = element_blank())



```
```{r bayesprism_pfs}
library(survminer)

for(i in colnames(bp.res@posterior.initial.cellType@theta)){
  mid_cell <- median(bp_res_celltype_fraction[,i])
  cell_high <- as.factor(ifelse(bp_res_celltype_fraction[,i]>=mid_cell, "high", "low"))
  cell_original <- bp_res_celltype_fraction[,i]
  names(cell_high) <- bp_res_celltype_fraction$RNA_FILE
  names(cell_original) <- bp_res_celltype_fraction$RNA_FILE
  tmp_df <- data.frame(sample = clinic$RNA_FILE, time = clinic$PFS, event = clinic$PFS_event, cell_high = factor(cell_high[clinic$RNA_FILE], levels = c("low", "high"), ordered = TRUE), cell_original = cell_original[clinic$RNA_FILE])
  print(survminer::ggsurvplot(fit = survfit(Surv(time, event)~cell_high, data = tmp_df),title = i, surv.median.line = "hv", pval = TRUE, break.time.by = 3, legend.title = "Cell-Type Fraction", legend.labs = levels(tmp_df$cell_high)))
}
```

```{r bayesprism_tapbp}
Z_tumor_matrix <- get.exp (bp=bp.res,
 state.or.type="type",
 cell.name="EpiT") %>% as.data.frame() %>%
  rownames_to_column(var = "RNA_FILE") %>%
  filter(RNA_FILE %in% clinic$RNA_FILE) %>% column_to_rownames("RNA_FILE")
granulo_fraction <- bp_res_celltype_fraction$Granulo
names(granulo_fraction) <- bp_res_celltype_fraction$RNA_FILE
macrophage_fraction <- bp_res_celltype_fraction$Macro
names(macrophage_fraction) <- bp_res_celltype_fraction$RNA_FILE
tcd8_fraction <- bp_res_celltype_fraction$TCD8
names(tcd8_fraction) <- bp_res_celltype_fraction$RNA_FILE
fibro_fraction <- bp_res_celltype_fraction$Fibro
names(fibro_fraction) <- bp_res_celltype_fraction$RNA_FILE
Tgd_fraction <- bp_res_celltype_fraction$Tgd
names(Tgd_fraction) <- bp_res_celltype_fraction$RNA_FILE
dc_fraction <- bp_res_celltype_fraction$DC
names(dc_fraction) <- bp_res_celltype_fraction$RNA_FILE

library(DESeq2)
GeneExp <- vst(round(t(Z_tumor_matrix)))
trans_id_z <- bitr(rownames(GeneExp[which(apply(GeneExp, 1, var)!=0),]), fromType = "ENSEMBL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
# gene_expr <- GeneExp[trans_id_z$ENSEMBL,] %>% magrittr::set_rownames(value = trans_id_z$ENTREZID)
gene_expr_original <- GeneExp[trans_id_z$ENSEMBL,] %>% magrittr::set_rownames(value = trans_id_z$ENTREZID)
gene_expr <- gene_expr_original
# gene_expr <- gene_expr[intersect(diff.exp.stat.entrez$ENTREZID, rownames(gene_expr)),]
hallmark_gmt <- msigdbr::msigdbr(species = "Homo sapiens", category = "H") %>% 
  dplyr::select(gs_name, entrez_gene)
granulo_corr <- lapply(rownames(gene_expr), function(x){
  tmp_x <- gene_expr[x,]
  tmp_y <- granulo_fraction[colnames(gene_expr)]
  tmp_cor <- cor(x = tmp_x, y = tmp_y, method = "spearman")
  return(tibble(gene = x, spearman_corr = tmp_cor))
}) %>% list_rbind() %>% arrange(desc(spearman_corr)) %>% mutate(celltype = "Granulo")

granulo_genelist <- granulo_corr$spearman_corr
names(granulo_genelist) <- granulo_corr$gene
gsea_res <- list()
gsea_res[["granulo_hallmark"]] <- GSEA(
  granulo_genelist,
  pvalueCutoff = 0.05,
  TERM2GENE = hallmark_gmt)
macro_corr <- lapply(rownames(gene_expr), function(x){
  tmp_x <- gene_expr[x,]
  tmp_y <- macrophage_fraction[colnames(gene_expr)]
  tmp_cor <- cor(x = tmp_x, y = tmp_y, method = "spearman")
  return(tibble(gene = x, spearman_corr = tmp_cor))
}) %>% list_rbind() %>% arrange(desc(spearman_corr)) %>% mutate(celltype = "Macro")
macro_genelist <- macro_corr$spearman_corr
names(macro_genelist) <- macro_corr$gene
gsea_res[["macro_hallmark"]] <- GSEA(
  macro_genelist,
  pvalueCutoff = 0.05,
  TERM2GENE = hallmark_gmt)
tcd8_corr <- lapply(rownames(gene_expr), function(x){
  tmp_x <- gene_expr[x,]
  tmp_y <- tcd8_fraction[colnames(gene_expr)]
  tmp_cor <- cor(x = tmp_x, y = tmp_y, method = "spearman")
  return(tibble(gene = x, spearman_corr = tmp_cor))
}) %>% list_rbind() %>% arrange(desc(spearman_corr)) %>% mutate(celltype = "TCD8")

tcd8_genelist <- tcd8_corr$spearman_corr
names(tcd8_genelist) <- tcd8_corr$gene

gsea_res[["tcd8_hallmark"]] <- GSEA(
  tcd8_genelist,
  pvalueCutoff = 0.05,
  TERM2GENE = hallmark_gmt)

fibro_corr <- lapply(rownames(gene_expr), function(x){
  tmp_x <- gene_expr[x,]
  tmp_y <- fibro_fraction[colnames(gene_expr)]
  tmp_cor <- cor(x = tmp_x, y = tmp_y, method = "spearman")
  return(tibble(gene = x, spearman_corr = tmp_cor))
}) %>% list_rbind() %>% arrange(desc(spearman_corr)) %>% mutate(celltype = "Fibro")

fibro_genelist <- fibro_corr$spearman_corr
names(fibro_genelist) <- fibro_corr$gene

gsea_res[["fibro_hallmark"]] <- GSEA(
  fibro_genelist,
  pvalueCutoff = 0.05,
  TERM2GENE = hallmark_gmt)

Tgd_corr <- lapply(rownames(gene_expr), function(x){
  tmp_x <- gene_expr[x,]
  tmp_y <- Tgd_fraction[colnames(gene_expr)]
  tmp_cor <- cor(x = tmp_x, y = tmp_y, method = "spearman")
  return(tibble(gene = x, spearman_corr = tmp_cor))
}) %>% list_rbind() %>% arrange(desc(spearman_corr)) %>% mutate(celltype = "Tgd")

Tgd_genelist <- Tgd_corr$spearman_corr
names(Tgd_genelist) <- Tgd_corr$gene
gsea_res[["Tgd_hallmark"]] <- GSEA(
  Tgd_genelist,
  pvalueCutoff = 0.05,
  TERM2GENE = hallmark_gmt)

dc_corr <- lapply(rownames(gene_expr), function(x){
  tmp_x <- gene_expr[x,]
  tmp_y <- dc_fraction[colnames(gene_expr)]
  tmp_cor <- cor(x = tmp_x, y = tmp_y, method = "spearman")
  return(tibble(gene = x, spearman_corr = tmp_cor))
}) %>% list_rbind() %>% arrange(desc(spearman_corr)) %>% mutate(celltype = "DC")

dc_genelist <- dc_corr$spearman_corr
names(dc_genelist) <- dc_corr$gene
gsea_res[["dc_hallmark"]] <- GSEA(
  dc_genelist,
  pvalueCutoff = 0.05,
  TERM2GENE = hallmark_gmt)

dotplot(gsea_res[["granulo_hallmark"]], split = ".sign", showCategory=10, label_format = 50) + facet_grid(~.sign)
dotplot(gsea_res[["macro_hallmark"]], split = ".sign", showCategory=10, label_format = 50) + facet_grid(~.sign)
dotplot(gsea_res[["tcd8_hallmark"]], split = ".sign", showCategory=10, label_format = 50) + facet_grid(~.sign)
dotplot(gsea_res[["fibro_hallmark"]], split = ".sign", showCategory=10, label_format = 50) + facet_grid(~.sign)
dotplot(gsea_res[["Tgd_hallmark"]], split = ".sign", showCategory=10, label_format = 50) + facet_grid(~.sign)
dotplot(gsea_res[["dc_hallmark"]], split = ".sign", showCategory=10, label_format = 50) + facet_grid(~.sign)

gsea_barplot <- function(x){
  library(forcats)
library(ggplot2)
library(ggstance)
library(enrichplot)
  y <- clusterProfiler::arrange(x, desc(abs(NES))) %>% 
        group_by(sign(NES)) %>% 
        clusterProfiler::slice(1:10)
paplot <- ggplot(y, aes(NES, fct_reorder(Description, NES), fill=p.adjust), showCategory=20) + 
  geom_barh(stat='identity') + 
  scale_fill_continuous(low='red', high='blue') + 
  theme_minimal() + ylab(NULL)+
  scale_y_discrete(labels = function(x) str_wrap(x, width = 30))
return(paplot)
}

# gsea_barplots <- list()
# gsea_barplots[["granulo_hallmark"]] <- gsea_barplot(gsea_res[["granulo_hallmark"]])
# gsea_barplots[["macro_hallmark"]] <- gsea_barplot(gsea_res[["macro_hallmark"]])
# gsea_barplots[["fibro_hallmark"]] <- gsea_barplot(gsea_res[["fibro_hallmark"]])
# gsea_barplots[["Tgd_hallmark"]] <- gsea_barplot(gsea_res[["Tgd_hallmark"]])
# gsea_barplots[["dc_hallmark"]] <- gsea_barplot(gsea_res[["dc_hallmark"]])

print(gsea_barplot(gsea_res[["granulo_hallmark"]]))
print(gsea_barplot(gsea_res[["macro_hallmark"]]))
print(gsea_barplot(gsea_res[["tcd8_hallmark"]]))
print(gsea_barplot(gsea_res[["fibro_hallmark"]]))
print(gsea_barplot(gsea_res[["Tgd_hallmark"]]))
print(gsea_barplot(gsea_res[["dc_hallmark"]]))

gene_corr <- rbind(fibro_corr, macro_corr, granulo_corr, Tgd_corr, dc_corr)
gene_corr_symbol <- bitr(gene_corr$gene, fromType = "ENTREZID", toType = "SYMBOL", OrgDb = org.Hs.eg.db)
gene_corr$symbol <- gene_corr_symbol$SYMBOL[match(gene_corr$gene, gene_corr_symbol$ENTREZID)]

### 抽提巨噬细胞的，查看极化情况
Z_macro_matrix <- t(get.exp (bp=bp.res,
 state.or.type="type",
 cell.name="Macro")   %>% as.data.frame() %>%
  rownames_to_column(var = "RNA_FILE") %>%
  filter(RNA_FILE %in% clinic$RNA_FILE) %>% column_to_rownames("RNA_FILE"))
Z_macro_matrix <- Z_macro_matrix[which(apply(Z_macro_matrix, 1, var)!=0),]
trans_id_z <- bitr(rownames(Z_macro_matrix), fromType = "ENSEMBL", toType = "SYMBOL", OrgDb = org.Hs.eg.db)
Z_macro_matrix <- Z_macro_matrix[trans_id_z$ENSEMBL,] %>% magrittr::set_rownames(value = trans_id_z$SYMBOL)

## LM22矩阵读取
macro_lm22 <- IOBR::lm22 %>% dplyr::select("Macrophages M2", "Macrophages M1")
others_lm22 <- IOBR::lm22 %>% dplyr::select(-c("Macrophages M2", "Macrophages M1"))

macro_lm22_marker <- macro_lm22[which(rowMax(as.matrix(macro_lm22))>rowMax(as.matrix(others_lm22))),]

## 计算M1和M2 Score
intersect_macro_markers <- intersect(rownames(Z_macro_matrix), rownames(macro_lm22_marker))
Z_macro_matrix_tiny <- merge(x = Z_macro_matrix[intersect_macro_markers,], y = macro_lm22_marker[intersect_macro_markers,], by = 0)
m1_pearson <- sapply(colnames(Z_macro_matrix), function(x){
  return(cor(Z_macro_matrix_tiny[,x], Z_macro_matrix_tiny[,"Macrophages M1"], method= "pearson"))
})
m2_pearson <- sapply(colnames(Z_macro_matrix), function(x){
  return(cor(Z_macro_matrix_tiny[,x], Z_macro_matrix_tiny[,"Macrophages M2"], method= "pearson"))
})

```

```{r bayesprism_tapbp}
tapbp_log2tpm <- as.matrix(tpm_log2_matrix)["TAPBP",bp_res_celltype_fraction$RNA_FILE]
tapbp_corr <- list()
for(i in colnames(bp.res@posterior.initial.cellType@theta)){
  cell_frac <- bp_res_celltype_fraction[,i]
  tmp_cor <- cor.test(x = tapbp_log2tpm, y = cell_frac, method = "spearman")
  tapbp_corr[[i]] <- data.frame(`Cell Type` = i,`Spearman Correlation`=tmp_cor$estimate, `P value` = tmp_cor$p.value)
}
tapbp_corr <- list_rbind(tapbp_corr)
tapbp_log2tpm <- as.matrix(tpm_log2_matrix)["TAPBP",colnames(gsva_res[["immune"]])]
tapbp_corr_gsva <- list()
for(i in rownames(gsva_res[["immune"]])){
  cell_frac <- gsva_res[["immune"]][i,]
  tmp_cor <- cor.test(x = tapbp_log2tpm, y = cell_frac, method = "spearman")
  tapbp_corr_gsva[[i]] <- data.frame(`Cell Type` = i,`Spearman Correlation`=tmp_cor$estimate, `P value` = tmp_cor$p.value)
}
tapbp_corr_gsva <- list_rbind(tapbp_corr_gsva)
```
```{r ssgsea_tapbp}
cor_matrix_data <- gsva_res[["immune"]]
cor_matrix_data_tapbp <- tpm_log2_matrix["TAPBP",colnames(cor_matrix_data)]
# cor_matrix_data <- rbind(cor_matrix_data, cor_matrix_data_tapbp) %>% t()

cor_matrix <- apply(cor_matrix_data, 1, function(x){
  fuck_tmp <- cor.test(x = x, y = unlist(cor_matrix_data_tapbp), method="spearman")
  return(data.frame(rho = fuck_tmp$estimate, pval = fuck_tmp$p.value))
})
cor_matrix <- list_rbind(cor_matrix, names_to = "Cell_Type")
cor_matrix$logp <- (-1)*log10(cor_matrix$pval)
corplot_tapbp <- ggplot(data = cor_matrix, mapping = aes(x = logp, y = rho, colour = Cell_Type, label = Cell_Type)) +
  geom_point(size = 5, show.legend = FALSE)+
  ggrepel::geom_label_repel(show.legend = FALSE)+
  theme_bw()+
  xlab("-log10P") +
  ylab("Spearman Correlation")
print(corplot_tapbp)
ggsave(filename = "Figure_Correlation.pdf",plot = corplot_tapbp, path = "./figures", units = "cm", width = 6, height = 10)
  
```
